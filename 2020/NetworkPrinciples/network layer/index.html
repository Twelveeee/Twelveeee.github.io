<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="十二的编程笔记" href="https://blog.twelveeee.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="十二的编程笔记" href="https://blog.twelveeee.top/atom.xml"><link rel="alternate" type="application/json" title="十二的编程笔记" href="https://blog.twelveeee.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><link rel="canonical" href="https://blog.twelveeee.top/2020/NetworkPrinciples/network%20layer/"><title>网络层 - 网络原理 - 计算机科学 | Twelveeee = 十二的编程笔记 = hello world</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">网络层</h1><div class="meta"><span class="item" title="创建时间：2020-06-09 23:38:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-06-09T23:38:00+08:00">2020-06-09</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>19k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>17 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Twelveeee</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_18.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_29.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_16.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_71.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_9.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_57.webp"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/networkPrinciple/" itemprop="item" rel="index" title="分类于 网络原理"><span itemprop="name">网络原理</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.twelveeee.top/2020/NetworkPrinciples/network%20layer/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Twelveeee"><meta itemprop="description" content="hello world, 十二的编程笔记"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="十二的编程笔记"></span><div class="body md" itemprop="articleBody"><h1 id="4网络层"><a class="anchor" href="#4网络层">#</a> 4. 网络层</h1><p>本章重点内容<br>网际协议 IP（即 IPv4)<br>划分子网和构造超网<br>互联网的路由选择协议<br>IPv6<br>虚拟专用网 VPN 和网络地址转换 NAT</p><h2 id="41-网络层提供的两种服务"><a class="anchor" href="#41-网络层提供的两种服务">#</a> 4.1 网络层提供的两种服务</h2><p>在计算机网络领域，网络层应该向运输层提供怎样的服务（“<strong>面向连接</strong>” 还是 “<strong>无连接</strong>”）<br>在计算机通信中，可靠交付应当由谁来负责？是网络还是端系统？</p><p>一种观点：让网络负责可靠交付<br>这种观点认为，应借助于电信网的成功经验，让网络负责可靠交付，计算机网络应模仿电信网络，使用<strong>面向连接</strong>的通信方式。<br>通信之前先建立<strong>虚电路 (Virtual Circuit)</strong>，以保证双方通信所需的一切网络资源。<br>如果再使用可靠传输的网络协议，就可使所发送的分组无差错按序到达终点，不丢失、不重复。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605165522948.png" alt="image-20200605165522948"><br>虚电路表示这只是一条<strong>逻辑上的</strong>连接，分组都沿着这条逻辑连接按照存储转发方式传送，而并不是真正建立了一条物理连接。<br>请注意，电路交换的电话通信是先建立了一条真正的连接。<br>因此分组交换的虚连接和电路交换的连接只是类似，但并不完全一样。</p><p>另一种观点：网络提供数据报服务<br>互联网的先驱者提出了一种崭新的网络设计思路。<br>网络层向上只提供简单灵活的、无连接的、尽最大努力交付的<strong>数据报服务</strong>。<br>网络在发送分组时不需要先建立连接。每一个分组（即 IP 数据报）独立发送，与其前后的分组无关（不进行编号）。<br><strong>网络层不提供服务质量</strong>的承诺。即所传送的分组可能出错、丢失、重复和失序（不按序到达终点），当然也不保证分组传送的时限。<br>由于传输网络不提供端到端的可靠传输服务，这就使网络中的路由器可以做得比较简单，而且价格低廉（与电信网的交换机相比较）。<br>如果主机（即端系统）中的进程之间的通信需要是可靠的，那么就由网络的主机中的运输层负责可靠交付（包括差错处理、流量控制等）。<br>采用这种设计思路的<strong>好处</strong>是：网络的造价大大降低，运行方式灵活，能够适应多种应用。<br>互连网能够发展到今日的规模，充分证明了当初采用这种设计思路的正确性。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605165656334.png" alt="image-20200605165656334"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605165741334.png" alt="image-20200605165741334"></p><h2 id="42-网际协议-ip"><a class="anchor" href="#42-网际协议-ip">#</a> 4.2 网际协议 IP</h2><p>网际协议 IP 是 TCP/IP 体系中两个最主要的协议之一。<br>与 IP 协议配套使用的还有三个协议：<br><strong>地址解析协议 ARP (Address Resolution Protocol)</strong><br><strong>网际控制报文协议 ICMP (Internet Control Message Protocol)</strong><br><strong>网际组管理协议 IGMP (Internet Group Management Protocol)</strong><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605165844957.png" alt="image-20200605165844957"></p><p><strong>4.2.1 虚拟互连网络</strong><br>将网络互连并能够互相通信，会遇到许多问题需要解决。<br>将网络互相连接起来要使用一些中间设备。中间设备又称为<strong>中间系统</strong>或<strong>中继 (relay) 系统</strong>。<br>有以下五种不同的中间设备：<br>物理层中继系统：<strong>转发器 (repeater)。</strong><br>数据链路层中继系统：<strong>网桥或桥接器 (bridge)</strong>。<br>网络层中继系统：<strong>路由器 (router)</strong>。<br>网桥和路由器的混合物：<strong>桥路器 (brouter)</strong>。<br>网络层以上的中继系统：<strong>网关 (gateway)</strong>。</p><p>当中继系统是转发器或网桥时，一般并不称之为网络互连，因为这仅仅是把一个网络扩大了，而这仍然是一个网络。<br>网关由于比较复杂，目前使用得较少。<br><strong>网络互连</strong>都是指用路由器进行网络互连和路由选择。<br>由于历史的原因，许多有关 TCP/IP 的文献将网络层使用的路由器称为<strong>网关</strong>。<img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605170148441.png" alt="image-20200605170148441"><br>虚拟互连网络的<strong>意义</strong><br>所谓虚拟互连网络也就是<strong>逻辑互连网络</strong>，它的意思就是互连起来的各种物理网络的异构性本来是客观存在的，但是我们利用 IP 协议就可以使这些性能各异的网络从用户看起来好像是<strong>一个统一的网络</strong>。<br>使用 IP 协议的虚拟互连网络可简称为<strong> IP 网</strong>。<br>使用虚拟互连网络的<strong>好处</strong>是：当互联网上的主机进行通信时，就好像在一个网络上通信一样，而看不见互连的各具体的网络异构细节。<br>如果在这种覆盖全球的 IP 网的上层使用 TCP 协议，那么就是现在的<strong>互联网 (Internet)</strong>。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605170323300.png" alt="image-20200605170323300"><br>如果我们只从网络层考虑问题，那么 IP 数据报就可以想象是在网络层中传送<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605170346129.png" alt="image-20200605170346129"></p><p><strong>4.2.2 分类的 IP 地址</strong><br>在 TCP/IP 体系中，IP 地址是一个最基本的概念。</p><p><strong>1. IP 地址及其表示方法</strong><br>我们把整个因特网看成为一个单一的、抽象的网络。<br>IP 地址就是给每个连接在互联网上的主机（或路由器）分配一个在全世界范围是<strong>唯一的 32 位的标识符</strong>。<br>IP 地址现在由<strong>互联网名字和数字分配机构 ICANN</strong> (Internet Corporation for Assigned Names and Numbers) 进行分配。<br>IP 地址的编址方法<br><strong>分类的 IP 地址</strong>。这是<strong>最基本的编址方法</strong>，在 1981 年就通过了相应的标准协议。<br><strong>子网的划分</strong>。这是对最基本的编址方法的<strong>改进</strong>，其标准 [RFC 950] 在 1985 年通过。<br><strong>构成超网。<strong>这是比较新的</strong>无分类编址</strong>方法。1993 年提出后很快就得到推广应用。</p><p>分类 IP 地址<br>将 IP 地址划分为若干个固定类。<br>每一类地址都由两个固定长度的字段组成，其中一个字段是<strong>网络号 net-id</strong>，它标志主机（或路由器）所连接到的网络，而另一个字段则是<strong>主机号 host-id</strong>，它标志该主机（或路由器）。<br>主机号在它前面的网络号所指明的网络范围内必须是唯一的。<br>由此可见，一个 IP 地址在整个互联网范围内是唯一的。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605170745601.png" alt="image-20200605170745601"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605170757057.png" alt="image-20200605170757057"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605170818813.png" alt="image-20200605170818813"><br>A 类地址的网络号字段 net-id 为 1 字节，A 类地址的主机号字段 host-id 为 3 字节。<br>B 类地址的网络号字段 net-id 为 2 字节，B 类地址的主机号字段 host-id 为 2 字节。<br>C 类地址的网络号字段 net-id 为 3 字节，C 类地址的主机号字段 host-id 为 1 字节。<br>D 类地址是多播地址，E 类地址保留为今后使用。</p><p><strong>2. 常用的三种类别的 IP 地址</strong><br>IP 地址的指派范围<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200605171040115.png" alt="image-20200605171040115"><br><strong>一般不使用的特殊的 IP 地址</strong></p><table><thead><tr><th>特殊地址</th><th>网络号</th><th>主机号</th><th>源地址或目的地址</th><th>说明</th></tr></thead><tbody><tr><td>网络地址</td><td>特定</td><td>全 0</td><td>都不是</td><td>表示某个网段如：123.123.123.0</td></tr><tr><td>直接广播地址</td><td>特定</td><td>全 1</td><td>目的地址</td><td>作为广播地址，分组传给该网络所有节点 123.123.123.255</td></tr><tr><td>受限广播地址</td><td>全 1</td><td>全 1</td><td>目的地址</td><td>分组发给本网络中的所有主机 255.255.255.255</td></tr><tr><td>本网络上的特定主机地址</td><td>全 0</td><td>特定</td><td>目的地址</td><td>本网内部的特定主机地址 0.0.0.123</td></tr><tr><td>本网络本主机</td><td>全 0</td><td>全 0</td><td>源地址</td><td>表示本机地址，仅在系统启动时使用，0.0.0.0</td></tr><tr><td>送回地址</td><td>127</td><td>任意</td><td>目的地址</td><td>用于网络软件测试与本地进程之间的通信。无论发送说明都会送回 127.0.0.1 localhost</td></tr></tbody></table><p>专用 IP 地址（私网地址）：仅用于组建的专用内部网（局域网），其他地址属于公网地址（Internet 地址），一般不用于局域网地址。</p><table><thead><tr><th>起始地址</th><th>终止地址</th><th>说明</th></tr></thead><tbody><tr><td>10.0.0.0</td><td>10.255.255.255</td><td>1 个连续的 A 类地址</td></tr><tr><td>172.16.0.0</td><td>172.31.255.255</td><td>16 个连续的 B 类地址</td></tr><tr><td>192.168.0.0</td><td>192.168.255.255</td><td>256 个连续的 C 类地址</td></tr></tbody></table><p><strong>IP 地址的一些重要特点：</strong><br>(1)<strong> IP 地址是一种分等级的地址结构</strong>。分两个等级的好处是：<br>第一，IP 地址管理机构在分配 IP 地址时只分配网络号，而剩下的主机号则由得到该网络号的单位自行分配。这样就方便了 IP 地址的管理<br>第二，路由器仅根据目的主机所连接的网络号来转发分组（而不考虑目的主机号），这样就可以使路由表中的项目数大幅度减少，从而减小了路由表所占的存储空间。<br>(2) 实际上 IP 地址是标志一个主机（或路由器）和一条链路的<strong>接口</strong>。<br>当一个主机同时连接到两个网络上时，该主机就必须同时具有两个相应的 IP 地址，其网络号 net-id 必须是不同的。这种主机称为多归<strong>属主机 (multihomed host)。</strong><br>由于一个路由器至少应当连接到两个网络（这样它才能将 IP 数据报从一个网络转发到另一个网络），因此一个路由器至少应当有两个不同的 IP 地址。<br>(3) 用转发器或网桥连接起来的若干个局域网仍为一个网络，因此这些局域网都具有同样的网络号 net-id。<br>(4) 所有分配到网络号 net-id 的网络，无论是范围很小的局域网，还是可能覆盖很大地理范围的广域网，都是平等的。</p><p><strong>4.2.3 IP 地址与硬件地址</strong><br>IP 地址与硬件地址是不同的地址。<br>从层次的角度看，<br><strong>硬件地址</strong>（或物理地址）是数据链路层和物理层使用的地址。<br><strong>IP 地址</strong>是网络层和以上各层使用的地址，是一种逻辑地址（称 IP 地址是逻辑地址是因为 IP 地址是用软件实现的）<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609185749398.png" alt="image-20200609185749398"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609185942877.png" alt="image-20200609185942877"><br>在 IP 层抽象的互联网上只能看到 IP 数据报。图中的 IP1 → IP2 表示从源地址 IP1 到目的地址 IP2 。<br>路由器只根据目的站的 IP 地址的网络号进行路由选择。<br>在具体的物理网络的链路层<br>只能看见 MAC 帧而看不见 IP 数据报<br>IP 层抽象的互联网屏蔽了下层很复杂的细节。在抽象的网络层上讨论问题，就能够使用统一的、抽象的 IP 地址研究主机和主机或主机和路由器之间的通信。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609190113602.png" alt="image-20200609190113602"><strong>4.2.4 地址解析协议 ARP</strong><br>通信时使用了两个地址：IP 地址（网络层地址）MAC 地址（数据链路层地址）<br>每个接口都有这两个地址</p><p>地址解析协议 ARP 的作用<br>已经知道了一个机器（主机或路由器）的 IP 地址，如何找出其相应的硬件地址？<br>地址解析协议 ARP 就是用来解决这样的问题的。<br><strong>ARP 作用</strong>：从网络层使用的 IP 地址，解析出在数据链路层使用的硬件地址。</p><p>不管网络层使用的是什么协议，在实际网络的链路上传送数据帧时，最终还是必须使用硬件地址。<br>每一个主机都设有一个<strong> ARP 高速缓存</strong> (ARP cache)，里面有所在的局域网上的各主机和路由器的 IP 地址到硬件地址的映射表。<br>&lt; IP address；MAC address；TTL &gt;<br>TTL (Time To Live)：地址映射有效时间。<br>当主机 A 欲向本局域网上的某个主机 B 发送 IP 数据报时，就先在其 ARP 高速缓存中查看有无主机 B 的 IP 地址。<br>如有，就可查出其对应的硬件地址，再将此硬件地址写入 MAC 帧，然后通过局域网将该 MAC 帧发往此硬件地址。<br>如没有， ARP 进程在本局域网上广播发送一个 ARP 请求分组。收到 ARP 响应分组后，将得到的 IP 地址到硬件地址的映射写入 ARP 高速缓存。</p><p><strong>ARP 请求分组</strong>：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址 (未知时填 0) / 目标方 IP 地址。<br><strong>本地广播 ARP 请求</strong>（路由器不转发 ARP 请求）。<br><strong>ARP 响应分组</strong>：包含发送方硬件地址 / 发送方 IP 地址 / 目标方硬件地址 / 目标方 IP 地址。<br><strong>ARP 分组封装在物理网络的帧中传输。</strong><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609190717815.png" alt="image-20200609190717815"><br>ARP 高速缓存的<strong>作用</strong><br>存放最近获得的 IP 地址到 MAC 地址的绑定，以减少 ARP 广播的数量。<br>为了减少网络上的通信量，主机 A 在发送其 ARP 请求分组时，就将自己的 IP 地址到硬件地址的映射写入 ARP 请求分组。<br>当主机 B 收到 A 的 ARP 请求分组时，就将主机 A 的这一地址映射写入主机 B 自己的 ARP 高速缓存中。这对主机 B 以后向 A 发送数据报时就更方便了。</p><p>ARP 是解决同一个局域网上的主机或路由器的 IP 地址和硬件地址的映射问题。<br>如果所要找的主机和源主机不在同一个局域网上，那么就要通过 ARP 找到一个位于本局域网上的某个路由器的硬件地址，然后把分组发送给这个路由器，让这个路由器把分组转发给下一个网络。剩下的工作就由下一个网络来做。<br>从 IP 地址到硬件地址的解析是自动进行的，主机的用户对这种地址解析过程是不知道的。<br>只要主机或路由器要和本网络上的另一个已知 IP 地址的主机或路由器进行通信，ARP 协议就会自动地将该 IP 地址解析为链路层所需要的硬件地址</p><p>为什么不直接使用硬件地址进行通信？<br>由于全世界存在着各式各样的网络，它们使用不同的硬件地址。要使这些异构网络能够互相通信就必须进行非常复杂的硬件地址转换工作，因此几乎是不可能的事。<br>IP 编址把这个复杂问题解决了。连接到互联网的主机只需各自拥有一个唯一的 IP 地址，它们之间的通信就像连接在同一个网络上那样简单方便，因为上述的调用 ARP 的复杂过程都是由计算机软件自动进行的，对用户来说是看不见这种调用过程的。<br>因此，在虚拟的 IP 网络上用 IP 地址进行通信给广大的计算机用户带来了很大的方便。</p><p><strong>4.2.5 IP 数据报的格式</strong><br>一个 IP 数据报由<strong>首部</strong>和<strong>数据</strong>两部分组成。<br>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。<br>在首部的固定部分的后面是一些可选字段，其长度是可变的。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609214001565.png" alt="image-20200609214001565"><br>首部的前一部分是固定长度，共 20 字节，是所有 IP 数据报必须具有的。可选字段，其长度是可变的<br>IP 数据报首部的固定部分中的各字段:<br>版本 —— 占 4 位，指 IP 协议的版本。目前的 IP 协议版本号为 4 (即 IPv4)。<br>首部长度 —— 占 4 位，可表示的最大数值是 15 个单位 (一个单位为 4 字节)，因此 IP 的首部长度的最大值是 60 字节。<br>区分服务 —— 占 8 位，用来获得更好的服务。在一般的情况下都不使用这个字段<br>总长度 —— 占 16 位，指首部和数据之和的长度，单位为字节，因此数据报的最大长度为 65535 字节。总长度必须不超过最大传送单元 MTU。<br>标识 (identification)—— 占 16 位，它是一个计数器，用来产生<strong> IP 数据报的标识</strong>。<br>标志 (flag)—— 占 3 位，目前只有前两位有意义。<br>标志字段的最低位是 MF (More Fragment)。MF=1 表示后面 “还有分片”。MF=0 表示最后一个分片。<br>标志字段中间的一位是 DF (Don't Fragment)。只有当 DF=0 时才允许分片。<br>片偏移 —— 占 13 位，指出：较长的分组在分片后，某片在原分组中的相对位置。片偏移以 8 个字节为偏移单位。<br>生存时间 —— 占 8 位，记为 TTL (Time To Live)，指示数据报在网络中可通过的路由器数的最大值。<br>协议 —— 占 8 位，指出此数据报携带的数据使用何种协议，以便目的主机的 IP 层将数据部分上交给那个处理过程<br>首部检验和 —— 占 16 位，<strong>只检验</strong>数据报的<strong>首部</strong>，不检验数据部分。这里不采用 CRC 检验码而采用简单的计算方法。<br>源地址和目的地址都各占 4 字节</p><p>【例】IP 数据报分片<br>一数据报的总长度为 3820 字节，其数据部分的长度为 3800 字节（使用固定首部），需要分片为长度不超过 1420 字节的数据报片。<br>因固定首部长度为 20 字节，因此每个数据报片的数据部分长度不能超过 1400 字节。<br>于是分为 3 个数据报片，其数据部分的长度分别为 1400、1400 和 1000 字节。<br>原始数据报首部被复制为各数据报片的首部，但必须修改有关字段的值。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609214911225.png" alt="image-20200609214911225"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609214920402.png" alt="image-20200609214920402"></p><p>首部检验和<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609214952129.png" alt="image-20200609214952129"></p><p>IP 数据报首部的可变部分<br>IP 首部的可变部分就是一个选项字段，用来支持排错、测量以及安全等措施，内容很丰富。<br>选项字段的长度可变，从 1 个字节到 40 个字节不等，取决于所选择的项目。<br>增加首部的可变部分是为了增加 IP 数据报的功能，但这同时也使得 IP 数据报的首部长度成为可变的。这就增加了每一个路由器处理数据报的开销。<br>实际上这些选项很少被使用。</p><p><strong>4.2.6 IP 层转发分组的流程</strong><br>假设：有四个 A 类网络通过三个路由器连接在一起。每一个网络上都可能有成千上万个主机。<br>可以想像，若按目的主机号来制作路由表，每一个路由表就有 4 万个项目，即 4 万行（每一行对应于一台主机），则所得出的路由表就会过于庞大。<br>但若按主机所在的网络地址来制作路由表，那么每一个路由器中的路由表就只包含 4 个项目（每一行对应于一个网络），这样就可使路由表大大简化。</p><p>在路由表中，对每一条路由，最主要的是，目的网络地址，下一跳地址<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609215341605.png" alt="image-20200609215341605"><br><strong>根据目的网络地址</strong>就能确定下一跳路由器，这样做的结果是：<br>IP 数据报最终一定可以找到目的主机所在目的网络上的路由器（可能要通过多次的间接交付）。只有到达最后一个路由器时，才试图向目的主机进行直接交付。<br>虽然互联网所有的分组转发都是基于目的主机所在的网络，但在大多数情况下都允许有这样的特例，即为特定的目的主机指明一个路由。<br>采用特定主机路由可使网络管理人员能更方便地控制网络和测试网络，同时也可在需要考虑某种安全问题时采用这种特定主机路由。<br>路由器还可采用<strong>默认路由</strong> (default route) 以减少路由表所占用的空间和搜索路由表所用的时间。<br>这种转发方式在一个网络只有很少的对外连接时是很有用的。<br>默认路由在主机发送 IP 数据报时往往更能显示出它的好处。<br>如果一个主机连接在一个小网络上，而这个网络只用一个路由器和互联网连接，那么在这种情况下使用默认路由是非常合适的。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609215555145.png" alt="image-20200609215555145"><br>IP 数据报的首部中<strong>没有</strong>地方可以用来指明 “下一跳路由器的 IP 地址”。<br>当路由器收到待转发的数据报，不是将下一跳路由器的 IP 地址填入 IP 数据报，而是<strong>送交</strong>下层的网络接口软件。<br>网络接口软件<strong>使用 ARP</strong> 负责将下一跳路由器的 IP 地址转换成硬件地址，并将此硬件地址放在链路层的 MAC 帧的首部，然后根据这个硬件地址找到下一跳路由器。</p><p>路由器分组转发算法<br>(1) 从数据报的首部提取目的主机的 IP 地址 D, 得出目的网络地址为 N。<br>(2) 若网络 N 与此路由器直接相连，则把数据报直接交付目的主机 D；否则是间接交付，执行 (3)。<br>(3) 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给路由表中所指明的下一跳路由器；否则，执行 (4)。<br>(4) 若路由表中有到达网络 N 的路由，则把数据报传送给路由表指明的下一跳路由器；否则，执行 (5)。<br>(5) 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器；否则，执行 (6)。<br>(6) 报告转发分组出错。</p><h2 id="43-划分子网和构造超网"><a class="anchor" href="#43-划分子网和构造超网">#</a> 4.3 划分子网和构造超网</h2><p><strong>4.3.1 划分子网</strong><br>1. 从两级 IP 地址到三级 IP 地址<br>在 ARPANET 的早期，IP 地址的设计确实不够合理：<br>(1) IP 地址空间的利用率有时很低。<br>(2) 给每一个物理网络分配一个网络号会使路由表变得太大因而使网络性能变坏。<br>(3) 两级的 IP 地址不够灵活。<br>三级 IP 地址<br>从 1985 年起在 IP 地址中又增加了一个 “<strong>子网号字段</strong>”，使两级的 IP 地址变成为<strong>三级的 IP 地址</strong>。<br>这种做法叫做<strong>划分子网</strong> (subnetting)。划分子网已成为互联网的正式标准协议。</p><p>划分子网的基本思路<br>划分子网纯属一个单位内部的事情。单位对外仍然表现为没有划分子网的网络。<br>从主机号借用若干个位作为子网号 subnet-id，而主机号 host-id 也就相应减少了若干个位。<br>凡是从其他网络发送给本单位某个主机的 IP 数据报，仍然是根据 IP 数据报的目的网络号 net-id，先找到连接在本单位网络上的路由器。<br>然后此路由器在收到 IP 数据报后，再按目的网络号 net-id 和子网号 subnet-id 找到目的子网。<br>最后就将 IP 数据报直接交付目的主机。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609215921622.png" alt="image-20200609215921622"></p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609220143665.png" alt="image-20200609220143665"><br>当没有划分子网时，IP 地址是两级结构。<br>划分子网后 IP 地址就变成了三级结构。<br>划分子网只是把 IP 地址的主机号 host-id 这部分进行再划分，而不改变 IP 地址原来的网络号 net-id。<br>优点：减少了 IP 地址的浪费使网络的组织更加灵活更便于维护和管理。<br>划分子网纯属一个单位内部的事情，对外部网络透明，对外仍然表现为没有划分子网的一个网络。</p><p><strong>2. 子网掩码</strong><br>从一个 IP 数据报的首部并无法判断源主机或目的主机所连接的网络是否进行了子网划分。<br>使用 ** 子网掩码 (subnet mask)** 可以找出 IP 地址中的子网部分。<br>规则：<br>子网掩码长度＝32 位<br>某位＝1：IP 地址中的对应位为网络号和子网号<br>某位＝0：IP 地址中的对应位为主机号</p><p>(IP 地址) AND (子网掩码)= 网络地址<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609221115213.png" alt="image-20200609221115213"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609221130615.png" alt="image-20200609221130615"><br><strong>子网掩码是一个网络或一个子网的重要属性</strong>。<br>路由器在和相邻路由器交换路由信息时，必须把自己所在网络（或子网）的子网掩码告诉相邻路由器。<br>路由器的路由表中的每一个项目，除了要给出目的网络地址外，还必须同时给出该网络的子网掩码。<br>若一个路由器连接在两个子网上就拥有两个网络地址和两个子网掩码。</p><p>子网划分方法<br>有<strong>固定长度子网</strong>和<strong>变长子网</strong>两种子网划分方法。<br>在采用固定长度子网时，所划分的所有子网的子网掩码都是<strong>相同</strong>的。<br>虽然根据已成为互联网标准协议的 RFC 950 文档，子网号不能为全 1 或全 0，但随着无分类域间路由选择 CIDR 的广泛使用，现在全 1 和全 0 的子网号也可以使用了，但一定要谨慎使用，确认你的路由器所用的路由选择软件是否支持全 0 或全 1 的子网号这种较新的用法。<br>划分子网增加了灵活性，但却减少了能够连接在网络上的主机总数。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609222126763.png" alt="image-20200609222126763"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609222138969.png" alt="image-20200609222138969"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609222151416.png" alt="image-20200609222151416"><br>以二进制看子网掩码，B 类地址的子网划分，如果子网掩码为 255.0=（11111111.00000000）8 个 1，那么有 (2^8)-2 个子网<br>如果有子网掩码为 252.0=（11111100.00000000）6 个 1，那么有 (2<sup>6)-2 个子网，有几个 0 就是每个子网的主机数 (2</sup> 零数)-2</p><p><strong>4.3.2 使用子网时分组的转发</strong><br>在不划分子网的两级 IP 地址下，从 IP 地址得出网络地址是个很简单的事。<br>但在划分子网的情况下，从 IP 地址却不能唯一地得出网络地址来，这是因为网络地址取决于那个网络所采用的子网掩码，但<strong>数据报的首部并没有提供子网掩码</strong>的信息。<br>因此分组转发的算法也必须做相应的改动。</p><p>在划分子网情况下路由器转发分组的算法<br>(1) 从收到的分组的首部提取目的 IP 地址 D。<br>(2) 先用各网络的子网掩码和 D 逐位相 “与”，看是否和相应的网络地址匹配。若匹配，则将分组直接交付。否则就是间接交付，执行 (3)。<br>(3) 若路由表中有目的地址为 D 的特定主机路由，则将分组传送给指明的下一跳路由器；否则，执行 (4)。<br>(4) 对路由表中的每一行，将子网掩码和 D 逐位相 “与”。若结果与该行的目的网络地址匹配，则将分组传送给该行指明的下一跳路由器；否则，执行 (5)。<br>(5) 若路由表中有一个默认路由，则将分组传送给路由表中所指明的默认路由器；否则，执行 (6)。<br>(6) 报告转发分组出错。</p><p>【例 4-4】已知互联网和路由器 R1 中的路由表。主机 H1 向 H2 发送分组。试讨论 R1 收到 H1 向 H2 发送的分组后查找路由表的过程。<br>要发送的分组的目的 IP 地址：128.30.33.138<img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609224640949.png" alt="image-20200609224640949"><br>因此 H1 首先检查主机 128.30.33.138 是否连接在本网络上如果是，则直接交付；否则，就送交路由器 R1，并逐项查找路由表。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609224739304.png" alt="image-20200609224739304"><br>因此 H1 必须把分组传送到路由器 R1 然后逐项查找路由表<br>255.255.255.128 AND 128.30.33.138 = 128.30.33.128 匹配<br>这表明子网 2 就是收到的分组所要寻找的目的网络。<br>符合目标网络地址 128.30.33.128 子网掩码 255.255.255.128，下一跳，接口 1。</p><p><strong>4.3.3 无分类编址 CIDR（构造超网）</strong><br>1. 网络前缀<br>划分子网在一定程度上缓解了互联网在发展中遇到的困难。然而在 1992 年互联网仍然面临三个必须尽早解决的问题：<br>(1) B 类地址在 1992 年已分配了近一半，眼看就要在 1994 年 3 月全部分配完毕！<br>(2) 互联网主干网上的路由表中的项目数急剧增长（从几千个增长到几万个）。<br>(3) 整个 IPv4 的地址空间最终将全部耗尽。<br>1987 年，RFC 1009 就指明了在一个划分子网的网络中可同时使用几个不同的子网掩码。<br>使用<strong>变长子网掩码 VLSM</strong> (Variable Length Subnet Mask) 可进一步提高 IP 地址资源的利用率。<br>在 VLSM 的基础上又进一步研究出无分类编址方法，它的正式名字是<strong>无分类域间路由选择 CIDR</strong>(Classless Inter-Domain Routing)。<br>CIDR 消除了传统的 A 类、B 类和 C 类地址以及划分子网的概念，因而可以更加有效地分配 IPv4 的地址空间。<br>CIDR 最主要的特点：<br>CIDR 使用各种长度的 “<strong>网络前缀</strong>”(network-prefix) 来代替分类地址中的网络号和子网号。<br>IP 地址从三级编址（使用子网掩码）又回到了两级编址。</p><p>无分类的两级编址的记法是：<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609225333951.png" alt="image-20200609225333951"><br>CIDR 使用 “<strong>斜线记法</strong>”(slash notation)，它又称为<strong> CIDR 记法</strong>，即在 IP 地址面加上一个斜线 “/”，然后写上网络前缀所占的位数（这个数值对应于三级编址中<strong>子网掩码中 1 的个数</strong>）。例如：220.78.168.0/24</p><p>CIDR 把网络前缀都相同的连续的 IP 地址组成 “<strong>CIDR 地址块</strong>”。<br>128.14.32.0/20 表示的地址块<strong>共有 2^12 个地址</strong>（因为斜线后面的 20 是<strong>网络前缀的位数</strong>，所以这个地址的主机号是 12 位）。<br>这个地址块的起始地址是 128.14.32.0。<br>在不需要指出地址块的起始地址时，也可将这样的地址块简称为 “/20 地址块”。<br>128.14.32.0/20 地址块的最小地址：128.14.32.0<br>128.14.32.0/20 地址块的最大地址：128.14.47.255<br><strong>全 0 和全 1 的主机号地址一般不使用。</strong></p><p><strong>路由聚合 (<strong>route aggregation)<br>一个 CIDR 地址块可以表示很多地址，这种地址的聚合常称为</strong>路由聚合</strong>，它使得路由表中的一个项目可以表示很多个（例如上千个）原来传统分类地址的路由。<br>路由聚合有利于减少路由器之间的路由选择信息的交换，从而提高了整个互联网的性能。<br>路由聚合也称为构成<strong>超网 (supernetting)</strong>。<br>CIDR 虽然不使用子网了，但仍然使用 “** 掩码”** 这一名词（但不叫子网掩码）。<br>对于 / 20 地址块，它的掩码是 20 个连续的 1。斜线记法中的数字就是掩码中 1 的个数。</p><p>CIDR 记法的其他形式<br>10.0.0.0/10 可简写为 10/10，也就是把点分十进制中低位连续的 0 省略。<br>10.0.0.0/10 隐含地指出 IP 地址 10.0.0.0 的掩码是 255.192.0.0。此掩码可表示为：11111111 11000000 00000000 00000000 有 10 个连续的 1<br>网络前缀的后面加一个星号<em>的表示方法，如 00001010 00</em>，在星号<em>之前是网络前缀，而星号</em>表示 IP 地址中的主机号，可以是任意值。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609231034741.png" alt="image-20200609231034741"><br>构成超网<br>前缀长度不超过 23 位的 CIDR 地址块都包含了多个 C 类地址。<br>这些 C 类地址合起来就构成了超网。<br>CIDR 地址块中的地址数一定是 2 的整数次幂。<br>网络前缀越短，其地址块所包含的地址数就越多。而在三级结构的 IP 地址中，划分子网是使网络前缀变长。<br>CIDR 的一个好处是：可以更加有效地分配 IPv4 的地址空间，可根据客户的需要分配适当大小的 CIDR 地址块。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609232555060.png" alt="image-20200609232555060"><br>这个 ISP 共有 64 个 C 类网络。如果不采用 CIDR 技术，则在与该 ISP 的路由器交换路由信息的每一个路由器的路由表中，就需要有 64 个项目。但采用地址聚合后，只需用路由聚合后的 1 个项目 206.0.64.0/18 就能找到该 ISP。</p><p>2. 最长前缀匹配<br>使用 CIDR 时，路由表中的每个项目由 “网络前缀” 和 “下一跳地址” 组成。在查找路由表时可能会得到不止一个匹配结果。<br>应当从匹配结果中<strong>选择具有最长网络前缀</strong>的路由：<strong>最长前缀匹配</strong> (longest-prefix matching)。<br>网络前缀越长，其地址块就越小，因而路由就越具体 (more specific)。<br>最长前缀匹配又称为<strong>最长匹配或最佳匹配</strong>。<br>【例】收到的分组的目的地址 D = 206.0.71.130<br>路由表中的项目：206.0.68.0/22 206.0.71.128/25<br>查找路由表中的第 1 个项目：<br>第 1 个项目 206.0.68.0/22 的掩码 M 有 22 个连续的 1。<br>M = 11111111 11111111 11111111 10000000<br>D = 206. 0. 01000111 . 130<br>= 206.0.68.0/22<br>第 2 个项目 206.0.71.128/25 的掩码 M 有 25 个连续的 1。<br>M = 11111111 11111111 11111111 10000000<br>D = 206. 0. 71. 10000010<br>=206.0.71.128/25<br>选择两个匹配的地址中更具体的一个，即选择最长前缀的地址。选第二个</p><p>3. 使用二叉线索查找路由表<br>当路由表的项目数很大时，怎样设法减小路由表的查找时间就成为一个非常重要的问题。<br>为了进行更加有效的查找，通常是将无分类编址的路由表存放在一种层次的数据结构中，然后自上而下地按层次进行查找。这里最常用的就是<strong>二叉线索</strong> (binary trie)。<br>IP 地址中从左到右的比特值决定了从根结点逐层向下层延伸的路径，而二叉线索中的各个路径就代表路由表中存放的各个地址。<br>为了提高二叉线索的查找速度，广泛使用了各种压缩技术。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200609233730698.png" alt="image-20200609233730698"></p><h2 id="44-网际控制报文协议-icmp"><a class="anchor" href="#44-网际控制报文协议-icmp">#</a> 4.4 网际控制报文协议 ICMP</h2><p>为了更有效地转发 IP 数据报和提高交付成功的机会，在网际层使用了网际控制报文协议 ICMP (Internet Control Message Protocol)。<br>ICMP 是互联网的标准协议。<br>ICMP 允许主机或路由器报告差错情况和提供有关异常情况的报告。<br>但 ICMP 不是高层协议（看起来好像是高层协议，因为 ICMP 报文是装在 IP 数据报中，作为其中的数据部分），而是 IP 层的协议。<br>ICMP 报文的格式<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610163932999.png" alt="image-20200610163932999"><br><strong>4.4.1 ICMP 报文的种类</strong><br>ICMP 报文的种类有两种，即 ICMP <strong>差错报告报文</strong>和 ICMP <strong>询问报文</strong>。<br>ICMP 报文的前 4 个字节是统一的格式，共有三个字段：即<strong>类型</strong>、<strong>代码</strong>和<strong>检验和</strong>。接着的 4 个字节的内容与 ICMP 的类型有关。</p><p>ICMP 差错报告报文共有 4 种 ：终点不可达 、时间超过、参数问题 、改变路由（重定向）(Redirect)<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610164213365.png" alt="image-20200610164213365"><br>不应发送 ICMP 差错报告报文的几种情况<br>对 ICMP 差错报告报文不再发送 ICMP 差错报告报文。<br>对第一个分片的数据报片的所有后续数据报片都不发送 ICMP 差错报告报文。<br>对具有多播地址的数据报都不发送 ICMP 差错报告报文。<br>对具有特殊地址（如 127.0.0.0 或 0.0.0.0）的数据报不发送 ICMP 差错报告报文。</p><p>ICMP 询问报文有两种 ：回送请求和回答报文、时间戳请求和回答报文<br>几种 ICMP 报文不再使用：信息请求与回答报文、掩码地址请求和回答报文、路由器询问和通告报文 、源点抑制报文</p><p><strong>4.4.2 ICMP 的应用举例</strong><br><strong>PING (Packet InterNet Groper)</strong><br>PING 用来测试两个主机之间的连通性。<br>PING 使用了 ICMP 回送请求与回送回答报文。<br>PING 是应用层直接使用网络层 ICMP 的例子，它没有通过运输层的 TCP 或 UDP。</p><p><strong>Traceroute 的应用举例</strong><br>在 Windows 操作系统中这个命令是 tracert。<br>用来跟踪一个分组从源点到终点的路径。<br>它利用 IP 数据报中的 TTL 字段和 ICMP 时间超过差错报告报文实现对从源点到终点的路径的跟踪。</p><h2 id="45-互联网的路由选择协议"><a class="anchor" href="#45-互联网的路由选择协议">#</a> 4.5 互联网的路由选择协议</h2><p><strong>4.5.1 有关路由选择协议的几个基本概念</strong></p><p>1. 理想的路由算法：<br>算法必须是正确的和完整的。 算法在计算上应简单。<br>算法应能适应通信量和网络拓扑的变化，这就是说，要有自适应性。<br>算法应具有稳定性。 算法应是公平的。 算法应是最佳的。</p><p>不存在一种绝对的最佳路由算法。<br>所谓 “最佳” 只能是相对于某一种特定要求下得出的较为合理的选择而已。<br>实际的路由选择算法，应尽可能接近于理想的算法。<br>路由选择是个非常复杂的问题</p><p><strong>静态</strong>路由选择策略 —— 即非自适应路由选择，其特点是简单和开销较小，但不能及时适应网络状态的变化。<br><strong>动态</strong>路由选择策略 —— 即自适应路由选择，其特点是能较好地适应网络状态的变化，但实现起来较为复杂，开销也比较大。</p><p>2. 分层次的路由选择协议<br>** 互联网采用分层次的路由选择协议。** 这是因为：<br>(1) 互联网的规模非常大。如果让所有的路由器知道所有的网络应怎样到达，则这种路由表将非常大，处理起来也太花时间。而所有这些路由器之间交换路由信息所需的带宽就会使互联网的通信链路饱和。<br>(2) 许多单位不愿意外界了解自己单位网络的布局细节和本部门所采用的路由选择协议（这属于本部门内部的事情），但同时还希望连接到互联网上。</p><p>自治系统 AS (Autonomous System)<br>自治系统 AS 的<strong>定义</strong>：在单一的技术管理下的一组路由器，而这些路由器使用一种 AS 内部的路由选择协议和共同的度量以确定分组在该 AS 内的路由，同时还使用一种 AS 之间的路由选择协议用以确定分组在 AS 之间的路由。<br>现在对自治系统 AS 的定义是强调下面的事实：尽管一个 AS 使用了多种内部路由选择协议和度量，但<strong>重要的是</strong>一个 AS 对其他 AS 表现出的是一个单一的和一致的路由选择策略。</p><p>互联网有两大类路由选择协议<br><strong>内部网关协议 IGP</strong> (Interior Gateway Protocol)<br>在一个自治系统<strong>内部使用</strong>的路由选择协议。<br>目前这类路由选择协议使用得最多，如 RIP 和 OSPF 协议。<br><strong>外部网关协议 EGP</strong> (External Gateway Protocol)<br>若源站和目的站处在不同的自治系统中，当数据报传到一个自治系统的边界时，就需要使用一种协议<strong>将路由选择信息传递到另一个自治系统中</strong>。这样的协议就是外部网关协议 EGP。<br>在外部网关协议中目前使用最多的是 BGP-4。</p><p>自治系统之间的路由选择也叫做<strong>域间路由选择 (interdomain routing)</strong>，在自治系统内部的路由选择叫做<strong>域内路由选择 (intradomain routing)</strong> 。</p><p><strong>#4.5.2 内部网关协议 RIP</strong></p><p>1. 工作原理:<br><strong>路由信息协议 RIP (Routing Information Protocol)</strong> 是内部网关协议 IGP 中最先得到广泛使用的协议。<br>RIP 是一种分布式的、基于距离向量的路由选择协议。<br>RIP 协议要求网络中的每一个路由器都要维护从它自己到其他每一个目的网络的<strong>距离</strong>记录。<br>RIP 协议中的 “距离” 也称为 “跳数”(hop count)，因为每经过一个路由器，跳数就加 1。<br>这里的 “距离” 实际上指的是 “最短距离”。<br>RIP 允许一条路径最多只能包含 15 个路由器。<br>RIP 不能在两个网络之间同时使用多条路由。<br>RIP 选择一个具有最少路由器的路由（即最短路由），哪怕还存在另一条高速 (低时延) 但路由器较多的路由。</p><p>RIP 协议的三个<strong>特点</strong> :<br>(1) 仅和<strong>相邻路由器</strong>交换信息。<br>(2) 交换的信息是当前本路由器所知道的<strong>全部信息</strong>，即自己的路由表。<br>(3) 按固定的时间间隔交换路由信息，例如，每隔 30 秒。当网络拓扑发生变化时，路由器也及时向相邻路由器通告拓扑变化后的路由信息。</p><p>路由表的建立<br>路由器在刚刚开始工作时，只知道到直接连接的网络的距离（此距离定义为 1）。它的路由表是空的。<br>以后，每一个路由器也只和数目非常有限的相邻路由器交换并更新路由信息。<br>经过若干次更新后，所有的路由器最终都会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器的地址。<br>RIP 协议的<strong>收敛</strong> (convergence) 过程较快。“收敛” 就是在自治系统中所有的结点都得到正确的路由选择信息的过程。</p><p>2. 距离向量算法：路由器收到相邻路由器（其地址为 X）的一个 RIP 报文：<br>(1) 先修改此 RIP 报文中的所有项目：把 “下一跳” 字段中的地址都改为 X，并把所有的 “距离” 字段的值加 1。<br>(2) 对修改后的 RIP 报文中的每一个项目，重复以下步骤：<br>（先比对网络）<br>若项目中的目的网络不在路由表中，则把该项目加到路由表中。<br>否则（接着比对网下一跳地址）<br>若下一跳字段给出的路由器地址是同样的，则把收到的项目替换原路由表中的项目。<br>否则（再比对距离）<br>若收到项目中的距离小于路由表中的距离，则进行更新，<br>否则，什么也不做。<br>(3) 若 3 分钟还没有收到相邻路由器的更新路由表，则把此相邻路由器记为不可达路由器，即将距离置为 16（表示不可达）。<br>(4) 返回。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610182152726.png" alt="image-20200610182152726"><br>3 .RIP2 协议的报文格式<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610182339973.png" alt="image-20200610182339973"><br>RIP2 报文由首部和路由部分组成。<br>RIP2 报文中的路由部分由若干个路由信息组成。每个路由信息需要用 20 个字节。地址族标识符（又称为<strong>地址类别</strong>）字段用来标志所使用的地址协议。<br>路由标记填入自治系统的号码，这是考虑使 RIP 有可能收到本自治系统以外的路由选择信息。<br>再后面指出某个网络地址、该网络的子网掩码、下一跳路由器地址以及到此网络的距离。<br>一个 RIP 报文最多可包括 25 个路由，因而 RIP 报文的最大长度是 4 + 20 x 25 = 504 字节。如超过，必须再用一个 RIP 报文来传送。<br>RIP2 具有简单的<strong>鉴别</strong>功能。<br>若使用鉴别功能，则将原来写入第一个路由信息（20 个字节）的位置用作鉴别。<br>在鉴别数据之后才写入路由信息，但这时最多只能再放入 24 个路由信息。<br>RIP 协议<strong>特点</strong>：好消息传播得快，坏消息传播得慢。<br>RIP 存在的一个<strong>问题</strong>：当网络出现故障时，要经过比较长的时间 (例如数分钟) 才能将此信息传送到所有的路由器。</p><p><strong>#4.5.3 内部网关协议 OSPF</strong><br>开放最短路径优先 OSPF (Open Shortest Path First) 是为克服 RIP 的缺点在 1989 年开发出来的。<br>OSPF 的原理很简单，但实现起来却较复杂。<br>1**.OSPF 协议的基本特点 **：<br>“<strong>开放</strong>” 表明 OSPF 协议不是受某一家厂商控制，而是公开发表的。<br>“<strong>最短路径优先</strong>” 是因为使用了 Dijkstra 提出的最短路径算法 SPF<br>采用<strong>分布式的链路状态协议 (link state protocol)</strong>。<br>注意：OSPF 只是一个协议的名字，它并不表示其他的路由选择协议不是 “最短路径优先”。<br>向本自治系统中所有路由器发送信息，这里使用的方法是<strong>洪泛法</strong>。<br>发送的信息就是与本路由器<strong>相邻</strong>的所有路由器的链路状态，但这只是路由器所知道的部分信息。<br><em>“链路状态” 就是说明本路由器都和哪些路由器相邻，以及该链路的 “<strong>度量</strong>”(metric)。</em><br>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息。</p><p>由于各路由器之间频繁地交换链路状态信息，因此所有的路由器最终都能建立一个<strong>链路状态数据库 (link-state database)</strong> 。<br>这个数据库实际上就是<strong>全网的拓扑结构图</strong>，它在全网范围内是一致的（这称为链路状态数据库的同步）。<br>OSPF 的链路状态数据库能较快地进行更新，使各个路由器能及时更新其路由表。<br>OSPF 的更新过程收敛得快是其重要优点。</p><p>为了使 OSPF 能够用于规模很大的网络，OSPF 将一个自治系统再划分为若干个更小的范围，叫做<strong>区域</strong> (area) 。<br>每一个区域都有一个 32 位的区域标识符（用点分十进制表示）。<br>区域也不能太大，在一个区域内的路由器最好不超过 200 个。<br>OSPF 划分为两种不同的区域<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610184613304.png" alt="image-20200610184613304"><br>划分区域的好处就是将利用洪泛法交换链路状态信息的范围局限于每一个区域而不是整个的自治系统，这就减少了整个网络上的通信量。<br>在一个区域内部的路由器只知道本区域的完整网络拓扑，而不知道其他区域的网络拓扑的情况。<br>OSPF <strong>使用层次结构的区域划分</strong>。在上层的区域叫做<strong>主干区域</strong> (backbone area)。<br>主干区域的标识符规定为 0.0.0.0。主干区域的作用是用来连通其他在下层的区域。</p><p>OSPF 不用 UDP 而是<strong>直接用</strong> IP 数据报传送。<br>OSPF 构成的数据报很短。这样做可减少路由信息的通信量。<br>数据报很短的另一好处是可以不必将长的数据报分片传送。<br>但分片传送的数据报只要丢失一个，就无法组装成原来的数据报，而整个数据报就必须重传。</p><p>OSPF 的其他特点<br>OSPF 对不同的链路可根据 IP 分组的不同服务类型 TOS 而设置成不同的代价。因此，<strong>OSPF 对于不同类型的业务可计算出不同的路由</strong>。<br>如果到同一个目的网络有多条相同代价的路径，那么可以将通信量分配给这几条路径。这叫做<strong>多路径间的负载平衡</strong>。<br>所有在 OSPF 路由器之间交换的分组都具有<strong>鉴别</strong>的功能。<br><strong>支持</strong>可变长度的子网划分和无分类编址 CIDR。<br>每一个链路状态都带上一个 32 位的序号，序号越大状态就越新。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610190203358.png" alt="image-20200610190203358"></p><p>2.OSPF 的五种分组类型<br>类型 1，问候 (Hello) 分组。<br>类型 2，数据库描述 (Database Description) 分组。<br>类型 3，链路状态请求 (Link State Request) 分组。<br>类型 4，链路状态更新 (Link State Update) 分组，用<strong>洪泛法</strong>对全网更新链路状态。<br>类型 5，链路状态确认 (Link State Acknowledgment) 分组。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610190322547.png" alt="image-20200610190322547"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610190339804.png" alt="image-20200610190339804"><br>OSPF 还规定每隔一段时间，如 30 分钟，要刷新一次数据库中的链路状态。<br>由于一个路由器的链路状态只涉及到与相邻路由器的连通状态，因而与整个互联网的规模并无直接关系。因此<strong>当</strong>互联网规模很大<strong>时</strong>，OSPF 协议要比距离向量协议 RIP 好得多。<br>OSPF 没有 “坏消息传播得慢” 的问题，据统计，其响应网络变化的时间小于 100 ms。</p><p>多点接入的局域网采用了<strong>指定的路由器</strong> (designated router) 的方法，使广播的信息量大大减少。<br>指定的路由器<strong>代表</strong>该局域网上所有的链路向连接到该网络上的各路由器发送状态信息。</p><p><strong>4.5.4 外部网关协议 BGP</strong><br>BGP 是<strong>不同自治系统的路由器之间</strong>交换路由信息的协议。<br>BGP 较新版本是 2006 年 1 月发表的 BGP-4（BGP 第 4 个版本），即 RFC 4271 ~ 4278。<br>可以将 BGP-4 简写为 BGP。</p><p>互联网的规模太大，使得自治系统之间路由选择非常困难。对于自治系统之间的路由选择，要寻找最佳路由是很不现实的。<br>当一条路径通过几个不同 AS 时，要想对这样的路径计算出有意义的代价是不太可能的。<br>比较合理的做法是在 AS 之间交换 “可达性” 信息。<br>自治系统之间的路由选择必须考虑有关策略。<br>因此，边界网关协议 BGP 只能是力求寻找一条能够到达目的网络且<strong>比较好</strong>的路由（不能兜圈子），而并<strong>非要</strong>寻找一条最佳路由。</p><p>每一个自治系统的管理员要选择至少一个路由器作为该自治系统的 “ <strong>BGP 发言人</strong>” (BGP speaker) 。<br>一般说来，两个 BGP 发言人都是通过一个共享网络连接在一起的，而 BGP 发言人往往就是 BGP 边界路由器，但也可以不是 BGP 边界路由器。<br>一个 BGP 发言人与其他自治系统中的 BGP 发言人要交换路由信息，就要先建立 <strong>TCP 连接</strong>，然后在此连接上交换 BGP 报文以建立 BGP 会话 (session)，利用 BGP <strong>会话</strong>交换路由信息。<br>使用 TCP 连接能提供可靠的服务，也简化了路由选择协议。<br>使用 TCP 连接交换路由信息的两个 BGP 发言人，彼此成为对方的<strong>邻站</strong> (neighbor) 或<strong>对等站</strong> (peer) 。</p><p>BGP 所交换的网络可达性的信息就是要到达某个网络所要经过的一系列 AS。<br>当 BGP 发言人互相交换了网络可达性的信息后，各 BGP 发言人就根据所采用的策略从收到的路由信息中找出到达各 AS 的较好路由。</p><p>BGP 协议的<strong>特点</strong>：<br>BGP 协议交换路由信息的结点数量级是自治系统数的量级，这要比这些自治系统中的网络数少很多。<br>每一个自治系统中 BGP 发言人（或边界路由器）的数目是很少的。这样就使得自治系统之间的路由选择不致过分复杂。<br>BGP-4 共使用四种报文 ：<br>(1) <strong>打开</strong> (OPEN) 报文，用来与相邻的另一个 BGP 发言人建立关系。<br>(2) <strong>更新</strong> (UPDATE) 报文，用来发送某一路由的信息，以及列出要撤消的多条路由。<br>(3) <strong>保活</strong> (KEEPALIVE) 报文，用来确认打开报文和周期性地证实邻站关系。<br>(4) <strong>通知</strong> (NOTIFICATION) 报文，用来发送检测到的差错。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610201742842.png" alt="image-20200610201742842"></p><p><strong>4.5.5 路由器的构成</strong><br>路由器是一种典型的网络层设备。<br>路由器是互联网中的关键设备。<br>路由器的主要作用是：连通不同的网络。选择信息传送的线路。选择通畅快捷的近路，能大大提高通信速度，减轻网络系统通信负荷，节约网络系统资源，提高网络系统畅通率，从而让网络系统发挥出更大的效益来。</p><p>1. 路由器的<strong>结构</strong><br>路由器是一种具有多个输入端口和多个输出端口的专用计算机，其任务是转发分组。也就是说，将路由器某个输入端口收到的分组，按照分组要去的目的地（即目的网络），把该分组从路由器的某个合适的输出端口转发给下一跳路由器。<br>下一跳路由器也按照这种方法处理分组，直到该分组到达终点为止。<br>路由器的<strong>转发分组</strong>正是网络层的主要工作。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610201909551.png" alt="image-20200610201909551"><br>整个的路由器结构可划分为两大部分：路由选择部分、分组转发部分。<br><strong>路由选择部分</strong>：<br>也叫做控制部分，其核心构件是路由选择处理机。<br>路由选择处理机的任务是根据所选定的路由选择协议构造出路由表，同时经常或定期地和相邻路由器交换路由信息而不断地更新和维护路由表。<br><strong>分组转发部分</strong>由三部分组成：<br><strong>交换结构</strong> (switching fabric)：又称为交换组织，其作用是根据<strong>转发表</strong> (forwarding table) 对分组进行处理。<br>一组输入端口<br>一组输出端口<br>（请注意：这里的端口就是硬件接口）</p><p>“转发” 和 “路由选择” 的区别<br>“<strong>转发</strong>”(forwarding) 就是路由器根据转发表将用户的 IP 数据报从合适的端口转发出去。<br>“<strong>路由选择</strong>”(routing) 则是按照分布式算法，根据从各相邻路由器得到的关于网络拓扑的变化情况，动态地改变所选择的路由。<br>路由表是根据路由选择算法得出的。而转发表是从路由表得出的。<br>在讨论路由选择的原理时，往往不去区分转发表和路由表的区别。</p><p>输入端口中的查找和转发功能在路由器的交换功能中是最重要的。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610202215505.png" alt="image-20200610202215505"><br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610202222726.png" alt="image-20200610202222726"><br>分组丢弃<br>若路由器处理分组的速率赶不上分组进入队列的速率，则队列的存储空间最终必定减少到零，这就使后面再进入队列的分组由于没有存储空间而只能被丢弃。<br>路由器中的输入或输出队列产生溢出是造成分组丢失的重要原因。</p><p>2.<strong> 交换结构</strong><br>交换结构是路由器的关键构件。<br>正是这个交换结构把分组从一个输入端口转移到某个合适的输出端口。<br>实现交换有多种方法。常用交换方法有三种：通过存储器、通过总线、通过纵横交换结构</p><p><strong>通过存储器</strong><br>当路由器的某个输入端口收到一个分组时，就用中断方式通知路由选择处理机。然后分组就从输入端口复制到存储器中。<br>路由器处理机从分组首部提取目的地址，查找路由表，再将分组复制到合适的输出端口的缓存中。<br>若存储器的带宽（读或写）为每秒 M 个分组，那么路由器的交换速率（即分组从输入端口传送到输出端口的速率）一定小于 M/2。<br><strong>通过总线</strong><br>数据报从输入端口通过共享的总线直接传送到合适的输出端口，而不需要路由选择处理机的干预。<br>因为每一个要转发的分组都要通过这一条总线，因此路由器的转发带宽就受总线速率的限制。<br>现代的技术已经可以将总线的带宽提高到每秒吉比特的速率，因此许多的路由器产品都采用这种通过总线的交换方式。<br><strong>通过纵横交换结构</strong> (crossbar switch fabric)<br>这种交换结构常称为互连网络 (interconnection network)。<br>它有 2N 条总线，可以使 N 个输入端口和 N 个输出端口相连接。<br>当输入端口收到一个分组时，就将它发送到与该输入端口相连的水平总线上。<br>若通向所要转发的输出端口的垂直总线是空闲的，则在这个结点将垂直总线与水平总线接通，然后将该分组转发到这个输出端口。<br>但若该垂直总线已被占用（有另一个分组正在转发到同一个输出端口），则后到达的分组就被阻塞，必须在输入端口排队。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/image-20200610202514920.png" alt="image-20200610202514920"></p><h2 id="46-ipv6"><a class="anchor" href="#46-ipv6">#</a> 4.6 IPv6</h2><p>IP 是互联网的核心协议。<br>互联网经过几十年的飞速发展，到 2011 年 2 月，IPv4 的 32 位地址已经耗尽。<br>ISP 已经不能再申请到新的 IP 地址块了。<br>我国在 2014 – 2015 年也逐步停止了向新用户和应用分配 IPv4 地址。<br>解决 IP 地址耗尽的根本措施就是采用具有更大地址空间的新版本的 IP，即 IPv6。</p><p><strong>4.6.1 IPv6 的基本首部</strong><br>IPv6 仍支持无连接的传送，但将协议数据单元 PDU 称为分组。为方便起见，本书仍采用数据报这一名词。<br>所引进的主要变化如下：<br>更大的地址空间。IPv6 将地址从 IPv4 的 32 位 增大到了 128 位。<br>扩展的地址层次结构。<br>灵活的首部格式。 IPv6 定义了许多可选的扩展首部。<br>改进的选项。 IPv6 允许数据报包含有选项的控制信息，其选项放在有效载荷中。</p><p>所引进的主要变化如下（续）：<br>允许协议继续扩充。<br>支持即插即用（即自动配置）。因此 IPv6 不需要使用 DHCP。<br>支持资源的预分配。 IPv6 支持实时视像等要求，保证一定的带宽和时延的应用。<br>IPv6 首部改为 8 字节对齐。首部长度必须是 8 字节的整数倍。原来的 IPv4 首部是 4 字节对齐。</p><p><strong>4.6.2 IPv6 的地址</strong><br><strong>4.6.3 从 IPv4 向 IPv6 过渡</strong><br><strong>4.6.4 ICMPv6</strong></p><p>4.7 IP 多播</p><p>4.8 虚拟专用网 VPN 和网络地址转换 NAT</p><h2 id="49-多协议标记交换-mpls"><a class="anchor" href="#49-多协议标记交换-mpls">#</a> 4.9 多协议标记交换 MPLS</h2></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2025-08-25 20:09:56" itemprop="dateModified" datetime="2025-08-25T20:09:56+08:00">2025-08-25</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Twelveeee <i class="ic i-at"><em>@</em></i>十二的编程笔记</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.twelveeee.top/2020/NetworkPrinciples/network%20layer/" title="网络层">https://blog.twelveeee.top/2020/NetworkPrinciples/network layer/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2020/NetworkPrinciples/data%20link%20layer/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;twelveeee-note.oss-cn-beijing.aliyuncs.com&#x2F;Image&#x2F;img&#x2F;bgimg_45.webp" title="数据链路层"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 网络原理</span><h3>数据链路层</h3></a></div><div class="item right"><a href="/2020/AI/intro%20of%20Neural%20Network/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;twelveeee-note.oss-cn-beijing.aliyuncs.com&#x2F;Image&#x2F;img&#x2F;bgimg_72.webp" title="神经网络简介"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> AI</span><h3>神经网络简介</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#4%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.</span> <span class="toc-text">4. 网络层</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%BD%91%E7%BB%9C%E5%B1%82%E6%8F%90%E4%BE%9B%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.1.</span> <span class="toc-text">4.1 网络层提供的两种服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E7%BD%91%E9%99%85%E5%8D%8F%E8%AE%AE-ip"><span class="toc-number">1.2.</span> <span class="toc-text">4.2 网际协议 IP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%88%92%E5%88%86%E5%AD%90%E7%BD%91%E5%92%8C%E6%9E%84%E9%80%A0%E8%B6%85%E7%BD%91"><span class="toc-number">1.3.</span> <span class="toc-text">4.3 划分子网和构造超网</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E7%BD%91%E9%99%85%E6%8E%A7%E5%88%B6%E6%8A%A5%E6%96%87%E5%8D%8F%E8%AE%AE-icmp"><span class="toc-number">1.4.</span> <span class="toc-text">4.4 网际控制报文协议 ICMP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E4%BA%92%E8%81%94%E7%BD%91%E7%9A%84%E8%B7%AF%E7%94%B1%E9%80%89%E6%8B%A9%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.5.</span> <span class="toc-text">4.5 互联网的路由选择协议</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-ipv6"><span class="toc-number">1.6.</span> <span class="toc-text">4.6 IPv6</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#49-%E5%A4%9A%E5%8D%8F%E8%AE%AE%E6%A0%87%E8%AE%B0%E4%BA%A4%E6%8D%A2-mpls"><span class="toc-number">1.7.</span> <span class="toc-text">4.9 多协议标记交换 MPLS</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/2020/NetworkPrinciples/intro/" rel="bookmark" title="网络原理概述">网络原理概述</a></li><li><a href="/2020/NetworkPrinciples/physical%20layer/" rel="bookmark" title="物理层">物理层</a></li><li><a href="/2020/NetworkPrinciples/data%20link%20layer/" rel="bookmark" title="数据链路层">数据链路层</a></li><li class="active"><a href="/2020/NetworkPrinciples/network%20layer/" rel="bookmark" title="网络层">网络层</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Twelveeee" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Twelveeee</p><div class="description" itemprop="description">十二的编程笔记</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">120</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">31</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R3ZWx2ZWVlZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;twelveeee"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnR3ZWx2ZWVlZTEyQGdtYWlsLmNvbQ==" title="mailto:twelveeee12@gmail.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cudHJhdmVsbGluZ3MuY24vZ28uaHRtbA=="><i class="ic i-paper-plane"></i>开往</span></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2020/NetworkPrinciples/data%20link%20layer/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2020/AI/intro%20of%20Neural%20Network/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/" title="分类于 GO">GO</a></div><span><a href="/2023/Go/go%20goroutine%20quicksort/" title="Go 协程实现快排">Go 协程实现快排</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/%E6%8E%92%E5%BA%8F/" title="分类于 排序">排序</a></div><span><a href="/2020/DataStructure/Sort/assignment%20sort/" title="排序">排序</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/highAvailability/" title="分类于 高可用">高可用</a></div><span><a href="/2023/HighAvailability/rate_limiter/" title="分布式限流设计与实现">分布式限流设计与实现</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/CTF/BCTF2024/" title="分类于 BCTF2024">BCTF2024</a></div><span><a href="/2024/CTF/BCTF2024/web_01/" title="BCTF2024-WEB-01~08">BCTF2024-WEB-01~08</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Search/" title="分类于 Search">Search</a></div><span><a href="/2023/Search/searchEngineResearch/" title="搜索引擎调研">搜索引擎调研</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/%E6%A0%88/" title="分类于 栈">栈</a></div><span><a href="/2020/DataStructure/Stack/stack%20application/" title="栈的应用">栈的应用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/CTF/BCTF2025/" title="分类于 BCTF2025">BCTF2025</a></div><span><a href="/2025/CTF/BCTF2025/misc_01/" title="BCTF2025-MISC-01~08">BCTF2025-MISC-01~08</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/%E7%9F%A9%E9%98%B5/" title="分类于 矩阵">矩阵</a></div><span><a href="/2020/DataStructure/Matrix/diagonal%20matrix/" title="对角矩阵">对角矩阵</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Linux%E5%9F%BA%E7%A1%80/" title="分类于 Linux 基础">Linux 基础</a></div><span><a href="/2020/Linux/Linux%20user%20permissions/" title="Linux用户身份与文件权限">Linux用户身份与文件权限</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Cache/" title="分类于 Cache">Cache</a></div><span><a href="/2021/Cache/difference%20between%20different%20caches/" title="不同缓存的区别">不同缓存的区别</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2025</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Twelveeee @ Twelveeee</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">617k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:20</span></div><div class="beian-by"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">闽ICP备20004781号</a></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2020/NetworkPrinciples/network layer/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?30195a9a0f4d22cd45e9d770a10c683f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F27X623LWT"></script><script data-pjax>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-F27X623LWT")</script>--></body></html>