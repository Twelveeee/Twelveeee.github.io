<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="十二的编程笔记" href="https://blog.twelveeee.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="十二的编程笔记" href="https://blog.twelveeee.top/atom.xml"><link rel="alternate" type="application/json" title="十二的编程笔记" href="https://blog.twelveeee.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="数据结构"><link rel="canonical" href="https://blog.twelveeee.top/2020/DataStructure/Graph/intro/"><title>图 - 图 - 数据结构 - 计算机科学 | Twelveeee = 十二的编程笔记 = hello world</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">图</h1><div class="meta"><span class="item" title="创建时间：2020-05-15 02:48:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2020-05-15T02:48:00+08:00">2020-05-15</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>14k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>13 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Twelveeee</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_88.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_42.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_27.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_61.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_45.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_69.webp"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/dataStructure/" itemprop="item" rel="index" title="分类于 数据结构"><span itemprop="name">数据结构</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/dataStructure/%E5%9B%BE/" itemprop="item" rel="index" title="分类于 图"><span itemprop="name">图</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.twelveeee.top/2020/DataStructure/Graph/intro/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Twelveeee"><meta itemprop="description" content="hello world, 十二的编程笔记"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="十二的编程笔记"></span><div class="body md" itemprop="articleBody"><h1 id="图"><a class="anchor" href="#图">#</a> 图</h1><h2 id="1定义"><a class="anchor" href="#1定义">#</a> 1. 定义</h2><p>1、<strong>图</strong>：<br>多对多的网状结构，图 G 由两个集合 V (G) 和 E (G) 组成，记作：G=(V,E)。<br>**V(G)<strong> 是顶点的非空有限集合。<br><strong>E(G)<strong> 是边的有穷集合，E (G) 可以是空集，如是空集则图 G 只有顶点没有边，而边是顶点偶对。<br>2、<strong>无向图</strong>：图 G 中的每条边都是没有方向的，通常用 ( ) 来表示。<br>3、<strong>有向图</strong>：图 G 中每条边都是有方向的，通常用 &lt; &gt; 来表示。<br>4、<strong>弧</strong>：有向边也称为弧。<br>5、<strong>弧尾</strong>：边的始点称为弧尾，或者初始点。<br>6、<strong>弧头</strong>：边的终点称为弧头，或者叫终端点。<br>7、<strong>n</strong> 表示顶点数，<strong>e</strong> 表示边数<br>无向图中边的数目为：0≤e≤n (n-1)/2 (另一半重复的原因)，<br>有向图中边的数目为：0≤e≤n (n-1)<br>8、<strong>无向完全图</strong>：恰好有 n (n-1)/2 条边的无向图称为无向完全图。<br>9、<strong>有向完全图</strong>：恰好有 n (n-1) 条边的有向图称为有向完全图。<br>注意：完全图具有最多的边数。任意一对顶点间均有边相连。<br>10、<strong>图的边和顶点的关系</strong><br>若 (vi,vj) 是一条无向边，则称顶点 vi 和 vj 互为</strong>邻接点 (Adjacent)</strong>，或称 vi 和 vj 相邻接；<br>并称 (vi,vj) 依附或</strong>关联 (Incident)** 于顶点 vi 和 vj，或称 (vi，vj) 与顶点 vi 和 vj 相关联。<br>若 &lt;vi，vj&gt; 是一条有向边，则称顶点 vi 邻接到 vj，顶点 vj 邻接于顶点 vi；<br>并称边 &lt;vi,vj&gt; 关联于 vi 和 vj 或称 &lt; vi，vj &gt; 与顶点 vi 和 vj 相关联。<br>11、<strong>无向图中的度</strong>：顶点的度指依附于某顶点 v 的边数，通常记为 D (v)。<br>12、<strong>入度</strong>：顶点 v 的入度是指以顶点 v 为终点的弧的数目。记为：ID (v)<br>13、<strong>出度</strong>：顶点 v 的出度是指以顶点 v 为始点的弧的数目。记为：OD (v)<br>14、<strong>边、顶点、度之间的关系</strong> (适应于有向图及无向图)<br>D (vi) 与顶点的个数以及边的数目满足关系：<br>E(G)=(D1+D2+….+Dn)/2<br>15、<strong>子图</strong><br>在图 G=(V,E)，G’=(V’,E’)，若 V’∈ V,E’∈ E，且 E’中的边所关联的节点都在 V‘中，则 G’是 G 的子图。<br>(通俗来讲就是 G 包含 G')<br>16、<strong>路径</strong> (有向图路径、无向图路径)<br>顶点 v 到 v‘的路径是一个顶点序列<br><strong>路径长度</strong>：路径上边的数目。<br>17、<strong>回路</strong>：Vp=Vq 的路径，即起点和终点相同，也称环。<br>18、<strong>简单路径</strong>：该路径上除 Vp 和 Vq 可相同外，其余顶点均不相同。<br>19、连通、连通图、连通分量<br><strong>连通</strong>：无向图中，若 vi 到 vj 有一条路径，则称 vi,vj 连通。<br><strong>连通图</strong>：无向图中若对于任意两个不同的顶点 vi 和 vj 都连通，称 G 为连通图。例：无向图 G3 和无向图 G4 都是连通图<br><strong>连通分量</strong>：无向图中 G 的最大连通子图称为 G 的连通分量。<br>20、强连通、强连通图、强连通分量<br><strong>强连通</strong>：有向图中，vi –vj 及 vj—vi 都有路径，则 vi,vj 强连通。<br><strong>强连通图</strong>：有向图中若对于作意两个不同的顶点 vi 和 vj 都存在从 vi 到 vj 及 vj 到 vi 的路径，则称 G 是强连通图。<br><strong>强连通分量</strong>：有向图的极大强连通子图称为 G 的强连通分量。<br>任何强连通图的强连通分量只有一个，即是其自身。<br>非强连通的有向图有多个强连通分量。<br>21、<strong>生成树</strong><br>一个连通图的生成树是一个极小连通子图。如果在一棵生成树上添加一条边，必定构成一个环。一棵有 N 个顶点的生成树有且仅有 N-1 条边。如果一个图有 N 个顶点和小于 N-1 条边，则是非连通图；如果多于 N-1 条边，则一定有环。有 N-1 条边的图不一定是生成树。</p><h2 id="2存储结构"><a class="anchor" href="#2存储结构">#</a> 2. 存储结构</h2><p>1. 邻接矩阵表示法</p><p>1) 基本思想<br>用一维数组存储图的顶点，用矩阵 (二维数组) 表示图中各顶点之间的邻接关系。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/20200513151920.png" alt=""></p><p>2) 邻接矩阵表示法的 C 语言描述如下</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_VERTEX_NUM</span> <span class="token expression"><span class="token number">20</span> 	</span><span class="token comment">/* 最多顶点个数 */</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INFINITY</span> <span class="token expression"><span class="token number">32768</span> 		</span><span class="token comment">/* 表示极大值，即∞*/</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/* 图的种类：DG 表示有向图，DN 表示有向网，UDG 表示无向图，UDN 表示无向网 */</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>DG<span class="token punctuation">,</span> DN<span class="token punctuation">,</span> UDG<span class="token punctuation">,</span> UDN<span class="token punctuation">&#125;</span> GraphKind<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">char</span> VertexData<span class="token punctuation">;</span> 		<span class="token comment">/* 假设顶点数据为字符型 */</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ArcNode</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    AdjType adj<span class="token punctuation">;</span> <span class="token comment">/* 对于无权图，用 1 或 0 表示是否相邻；对带权图，则为权值类型 */</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	OtherInfo info<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token punctuation">&#125;</span> ArcNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	VertexData vertex<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 顶点向量 */</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	ArcNode arcs <span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 邻接矩阵 */</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token keyword">int</span> vexnum<span class="token punctuation">,</span> arcnum<span class="token punctuation">;</span> 		<span class="token comment">/* 图的顶点数和弧数 */</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	GraphKind kind<span class="token punctuation">;</span> 			<span class="token comment">/* 图的种类标志 */</span></pre></td></tr><tr><td data-num="15"></td><td><pre><span class="token punctuation">&#125;</span>AdjMatrix<span class="token punctuation">;</span> 					<span class="token comment">/*(Adjacency Matrix Graph) 邻接矩阵 */</span></pre></td></tr><tr><td data-num="16"></td><td><pre></pre></td></tr><tr><td data-num="17"></td><td><pre><span class="token comment">/* 求顶点位置函数 */</span></pre></td></tr><tr><td data-num="18"></td><td><pre><span class="token keyword">int</span> <span class="token function">LocateVertex</span><span class="token punctuation">(</span>AdjMatrix <span class="token operator">*</span> G<span class="token punctuation">,</span> VertexData v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token keyword">int</span> j<span class="token operator">=</span>Error<span class="token punctuation">,</span>k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="21"></td><td><pre> 		<span class="token keyword">if</span><span class="token punctuation">(</span>G<span class="token operator">-></span>vertex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">==</span>v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>            j<span class="token operator">=</span>k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>            <span class="token keyword">break</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="25"></td><td><pre> 		<span class="token keyword">return</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">int</span> <span class="token function">CreateDN</span><span class="token punctuation">(</span>AdjMatrix <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> <span class="token comment">/* 创建一个有向网 */</span></pre></td></tr><tr><td data-num="29"></td><td><pre>	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">,</span>weight<span class="token punctuation">;</span> VertexData v1<span class="token punctuation">,</span>v2<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token operator">-></span>arcnum<span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token operator">-></span>vexnum<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 输入图的顶点数和弧数 */</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">/* 初始化邻接矩阵 */</span></pre></td></tr><tr><td data-num="32"></td><td><pre>		<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="33"></td><td><pre>			G<span class="token operator">-></span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token operator">=</span>INFINITY<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>G<span class="token operator">-></span>vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 输入图的顶点 */</span></pre></td></tr><tr><td data-num="35"></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>k<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>G<span class="token operator">-></span>arcnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%c,%c,%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>v1<span class="token punctuation">,</span><span class="token operator">&amp;</span>v2<span class="token punctuation">,</span><span class="token operator">&amp;</span>weight<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">/* 输入一条弧的两个顶点及权值 */</span></pre></td></tr><tr><td data-num="37"></td><td><pre> 		i<span class="token operator">=</span><span class="token function">LocateVex_M</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v1<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre> 		j<span class="token operator">=</span><span class="token function">LocateVex_M</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>v2<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="39"></td><td><pre> 		G<span class="token operator">-></span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token operator">=</span>weight<span class="token punctuation">;</span> <span class="token comment">/* 建立弧 */</span></pre></td></tr><tr><td data-num="40"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="41"></td><td><pre> 	<span class="token keyword">return</span><span class="token punctuation">(</span>Ok<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>2. 邻接表表示法<br>1) 基本思想<br>只存储图中有关联的边的信息，对图中 n 个顶点均建立有关联的边链表<br>每个顶点信息与其边链表的头指针构成<strong>表头结点表</strong></p><p>2) 结构构成<br>一个 N 个顶点的图的邻接表由<strong>表头结点表</strong>和<strong>边表</strong>两部分构成<br>表头结点表构成数据域 (vexdata)| 链域 (firstarc)<br>边标构成临界点域 (adjvex)| 链域 (nextarc)| 数据域 (info)</p><p>3) 邻接表存储结构的形式化说明如下：</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">MAX_VERTEX_NUM</span> <span class="token expression"><span class="token number">20</span> </span><span class="token comment">/* 最多顶点个数 */</span></span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">enum</span><span class="token punctuation">&#123;</span>DG<span class="token punctuation">,</span> DN<span class="token punctuation">,</span> UDG<span class="token punctuation">,</span> UDN<span class="token punctuation">&#125;</span> GraphKind<span class="token punctuation">;</span> <span class="token comment">/* 图的种类 */</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">ArcNode</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">int</span> adjvex<span class="token punctuation">;</span> <span class="token comment">/* 该弧指向顶点的位置 */</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">struct</span> <span class="token class-name">ArcNode</span> <span class="token operator">*</span>nextarc<span class="token punctuation">;</span> <span class="token comment">/* 指向下一条弧的指针 */</span></pre></td></tr><tr><td data-num="6"></td><td><pre> 	OtherInfo info<span class="token punctuation">;</span> <span class="token comment">/* 与该弧相关的信息 */</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">&#125;</span> ArcNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">VertexNode</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> 	VertexData data<span class="token punctuation">;</span> <span class="token comment">/* 顶点数据 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre> 	ArcNode <span class="token operator">*</span>firstarc<span class="token punctuation">;</span> <span class="token comment">/* 指向该顶点第一条弧的指针 */</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">&#125;</span> VertexNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> 	VertexNode vertex<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> 	<span class="token keyword">int</span> vexnum<span class="token punctuation">,</span>arcnum<span class="token punctuation">;</span> <span class="token comment">/* 图的顶点数和弧数 */</span></pre></td></tr><tr><td data-num="15"></td><td><pre> 	GraphKind kind<span class="token punctuation">;</span> <span class="token comment">/* 图的种类标志 */</span></pre></td></tr><tr><td data-num="16"></td><td><pre><span class="token punctuation">&#125;</span>AdjList<span class="token punctuation">;</span> <span class="token comment">/* 基于邻接表的图 (Adjacency List Graph)*/</span></pre></td></tr></table></figure><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/20200513161400.png" alt=""></p><p>3. 十字链表<br>1) 定义<br>十字链表 (Orthogonal List) 是有向图的另一种链式存储结构。可以把它看成是 将有向图的邻接表和逆邻接表结合起来形成的一种链表。有向图中的每一条弧对应十字链表中的一个弧结点，同时有向图中的每个顶点在十字链表中对应有一个结点，叫做顶点结点。<br>2) 结构构成<br>十字链表由顶点结点和弧结点构成<br>顶点节点 data|| 链域 firstin<br>弧结点 弧尾结点 (tailvex) | 弧头结点 (headvex) | 头的下一条弧 (hlink) | 尾的下一条弧 (tlink)</p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/20200513162302.png" alt=""></p><p>4. 邻接多重表</p><p>邻接多重表 (Adjacency Multi_list) 是无向图的另外一种存储结构，邻接多重表是指将图中关于一条边的信息用一个结点来表示，</p><h2 id="3图的遍历"><a class="anchor" href="#3图的遍历">#</a> 3. 图的遍历</h2><p>与树的遍历相似，若从图中某顶点出发访遍图中每个顶点，且每个顶点仅访问一次，此过程称为图的遍历 (Traversing Graph)。</p><p>1. 深度优先遍历 (DFS)<br>1) 基本思想：给定一个连通子图，从图中某个结点 v1 出发，首先访问出发点 v1，然后选择一个 v1 的未被访问过的邻接点 v2，以 v2 为新的出发点继续进行深度优先遍历，当遇到一个所有邻接于它的顶点都被访问过时，则回到已访问顶点中最后一个拥有未被访问的相邻顶点，再进行深度优先，直至所有的顶点都被访问。直到子图中所有结点都被访问过 (递归定义)。若此时图中仍有未访问的结点，则另找一个连通子图，重复上述操作，直到图中所有的结点都被访问过。<br>特点：尽可能先对纵深方向进行搜索。</p><p>2) 算法实现</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 主函数</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">DFSTraverseAL</span><span class="token punctuation">(</span>ALGraph <span class="token operator">*</span>G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">/* 深度优先遍历以邻接表存储的图 G*/</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token operator">-></span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>FALSE<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token operator">-></span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre><span class="token comment">/* 以 Vi 为出发点对邻接表存储的图 G 进行 DFS 搜索 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token keyword">void</span> <span class="token function">DFS</span><span class="token punctuation">(</span>ALGraph <span class="token operator">*</span>G<span class="token punctuation">,</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>	EdgeNode <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>	<span class="token comment">//visit(v0);</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"visit vertex:V%c\n"</span><span class="token punctuation">,</span>G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>vertex<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 访问顶点 Vi*/</span></pre></td></tr><tr><td data-num="14"></td><td><pre>	visited<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	p<span class="token operator">=</span>G<span class="token operator">-></span>adjlist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstedge<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            <span class="token function">DFS</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	p<span class="token operator">=</span>p<span class="token operator">-></span>next<span class="token punctuation">;</span><span class="token comment">// 下一个邻接点</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre></pre></td></tr><tr><td data-num="24"></td><td><pre><span class="token comment">// 用邻接矩阵方式实现深度优先搜索，图 g 为邻接矩阵类型 AdjMatrix</span></pre></td></tr><tr><td data-num="25"></td><td><pre><span class="token keyword">void</span> <span class="token function">DepthFirstSearch</span><span class="token punctuation">(</span>AdjMatrix g<span class="token punctuation">,</span> <span class="token keyword">int</span> v0<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	<span class="token function">visit</span><span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="27"></td><td><pre>    visited<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token operator">=</span>True<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span> vj<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>vj<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>vj<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="29"></td><td><pre> 		<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>vj<span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">[</span>vj<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token operator">==</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="30"></td><td><pre>			<span class="token function">DepthFirstSearch</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> vj<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre><span class="token punctuation">&#125;</span><span class="token comment">/* DepthFirstSearch */</span></pre></td></tr><tr><td data-num="32"></td><td><pre></pre></td></tr><tr><td data-num="33"></td><td><pre><span class="token comment">// 用邻接表方式实现深度优先搜索，图 g 为邻接表类型 AdjList</span></pre></td></tr><tr><td data-num="34"></td><td><pre><span class="token keyword">void</span> <span class="token function">DepthFirstSearch</span><span class="token punctuation">(</span>AdjList g<span class="token punctuation">,</span> <span class="token keyword">int</span> v0<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>    <span class="token function">visit</span><span class="token punctuation">(</span>v0<span class="token punctuation">)</span> <span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>    visited<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token operator">=</span>True<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	p<span class="token operator">=</span>g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="38"></td><td><pre>	<span class="token keyword">while</span><span class="token punctuation">(</span> p<span class="token operator">!=</span><span class="token constant">NULL</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> visited<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="40"></td><td><pre>			<span class="token function">DepthFirstSearch</span><span class="token punctuation">(</span>g<span class="token punctuation">,</span> p<span class="token operator">-></span>adjvex<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre>		p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="42"></td><td><pre> 	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="43"></td><td><pre><span class="token punctuation">&#125;</span><span class="token comment">/*DepthFirstSearch*/</span></pre></td></tr></table></figure><p>2. 广度优先遍历<br>广度优先遍历 (Breadth_First Search) 是指按照广度方向搜索，它类似于树的层次遍历，是树的按层次遍历的推广。<br>1) 基本思想<br>(1) 从图中某个顶点 v0 出发，首先访问 v0。<br>(2) 依次访问 v0 的各个未被访问的邻接点。<br>(3) 分别从这些邻接点 (端结点) 出发，依次访问它们的各个未被访问的邻接点 (新的端结点)。访问时应保证：如果 Vi 和 Vk 为当前端结点，且 Vi 在 Vk 之前被访问，则 Vi 的所有未被访问的邻接点应在 Vk 的所有未被访问的邻接点之前访问。重复 (3)，直到所有端结点均没有未被访问的邻接点为止。若此时还有顶点未被访问，则选一个未被访问的顶点作为起始点，重复上述过程，直至所有顶点均被访问过为止。</p><p>2) 算法实现</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/* 广度优先搜索图 g 中 v0 所在的连通子图 */</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">void</span> <span class="token function">BreadthFirstSearch</span><span class="token punctuation">(</span>Graph g<span class="token punctuation">,</span> <span class="token keyword">int</span> v0<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>	<span class="token function">visit</span><span class="token punctuation">(</span>v0<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    visited<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token operator">=</span>True<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token function">InitQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 初始化空队 */</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token function">EnterQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> v0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* v0 进队 */</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	<span class="token keyword">while</span> <span class="token punctuation">(</span> <span class="token operator">!</span> <span class="token function">Empty</span><span class="token punctuation">(</span>Q<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        <span class="token function">DeleteQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> <span class="token operator">&amp;</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 队头元素出队 */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>		w<span class="token operator">=</span><span class="token function">FirstAdjVertex</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 求 v 的第一个邻接点 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		<span class="token keyword">while</span> <span class="token punctuation">(</span>w<span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>                <span class="token function">visit</span><span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>                visited<span class="token punctuation">[</span>w<span class="token punctuation">]</span><span class="token operator">=</span>True<span class="token punctuation">;</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>				<span class="token function">EnterQueue</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>Q<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>			w<span class="token operator">=</span><span class="token function">NextAdjVertex</span> <span class="token punctuation">(</span>g<span class="token punctuation">,</span> v<span class="token punctuation">,</span> w<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 求 v 相对于 w 的下一个邻接点 */</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	 	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="4图的连通性"><a class="anchor" href="#4图的连通性">#</a> 4. 图的连通性</h2><p>1. 无向图的连通分量<br>可以利用图的遍历过程来判断一个图是否连通。如果在遍历的过程中，不止一次调用搜索过程，则说明该图就是一个非连通图。几次调用搜索过程，表明该图就有几个连通分量。</p><p>2. 图中两个顶点之间的简单路径<br>在图的应用问题中，常常需要找从顶点 u 到另一个顶点 v 的简单路径，即路径中的顶点均不相同。u 到 v 可能存在多条简单路径，由于遍历过程将走遍图中的所有顶点，故可以在深度 (或广度) 优先搜索算法基础上加以适当的条件，就能得到求解此问题的算法，因此可以将此问题看成是有条件的图遍历过程。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 深度优先找出从顶点 u 到 v 的简单路径</span></pre></td></tr><tr><td data-num="2"></td><td><pre></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">int</span> <span class="token operator">*</span>pre<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">/* 在连通图 G 中找一条从第 u 个顶点到 v 个顶点的简单路径 */</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">void</span> <span class="token function">one_path</span><span class="token punctuation">(</span>Graph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	pre<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token function">malloc</span><span class="token punctuation">(</span>G<span class="token operator">-></span>vexnum<span class="token operator">*</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token operator">-></span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> pre<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre> 	pre<span class="token punctuation">[</span>u<span class="token punctuation">]</span><span class="token operator">=</span>u<span class="token punctuation">;</span> <span class="token comment">/* 将 pre [u] 置为非 - 1，表示第 u 个顶点已被访问 */</span></pre></td></tr><tr><td data-num="10"></td><td><pre> 	<span class="token function">DFS_path</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> u<span class="token punctuation">,</span> v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 用深度优先搜索找一条从 u 到 v 的简单路径。*/</span></pre></td></tr><tr><td data-num="11"></td><td><pre>	<span class="token function">free</span><span class="token punctuation">(</span>pre<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="13"></td><td><pre> <span class="token comment">/* 在连通图 G 中用深度优先搜索策略找一条从 u 到 v 的简单路径。*/</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">void</span> <span class="token function">DFS_path</span><span class="token punctuation">(</span>Graph <span class="token operator">*</span>G<span class="token punctuation">,</span> <span class="token keyword">int</span> u<span class="token punctuation">,</span> <span class="token keyword">int</span> v<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token keyword">int</span> j<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre> 	<span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>v<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre> 		<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token function">firstadj</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>u<span class="token punctuation">)</span><span class="token punctuation">;</span>j<span class="token operator">>=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">=</span><span class="token function">nextadj</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>u<span class="token punctuation">,</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre> 			<span class="token keyword">if</span><span class="token punctuation">(</span>pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> 				pre<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>u<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> 				<span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">==</span>v<span class="token punctuation">)</span> <span class="token function">print_path</span><span class="token punctuation">(</span>pre <span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 输出路径 */</span></pre></td></tr><tr><td data-num="21"></td><td><pre> 				<span class="token keyword">else</span> <span class="token function">DFS_path</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>j<span class="token punctuation">,</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> 			<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>3. 图的生成树与最小生成树</p><p>1) 生成树<br>图的极小连通子图。即：对于有 n 个顶点的无向连通图，无论其生成树的形态如何，所有生成树中都有且仅有 n－1 条边。</p><p>2) 最小生成树<br>在一个连通网的所有生成树中，各边的代价之和最小的那棵生成树称为该连通网的最小代价生成树 (Minimum Cost Spanning Tree)，简称为最小生成树 (MST)。</p><p>3) 最小生成树方法</p><p>1. 普里姆 (prim) 算法<br>假设 G＝(V，E) 为一网图，其中 V 为网图中所有顶点的集合，E 为网图中所有带权边的集合。设置两个新的集合 U 和 T，其中集合 U 用于存放 G 的最小生成树中的顶点，集合 T 存放 G 的最小生成树中的边。令集合 U 的初值为 U＝{u1}(假设构造最小生成树时，从顶点 u1 出发)，集合 T 的初值为 T＝{}</p><p>Prim 算法的思想是，从所有 u∈U，v∈V－U 的边中，选取具有最小权值的边 (u，v)，将顶点 v 加入集合 U 中，将边 (u，v) 加入集合 T 中，如此不断重复，直到 U＝V 时，最小生成树构造完毕，这时集合 T 中包含了最小生成树的所有边。<br>通俗来讲就是，根目录下，找到每一个权值最小的边，把边连接起来，不要相互连通。</p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/20200514232533.png" alt=""></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">struct</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>	VertexData adjvex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">int</span> lowcost<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span> closedge<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 求最小生成树时的辅助数组 */</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token comment">/* 从顶点 u 出发，按普里姆算法构造连通网 gn 的最小生成树，并输出生成树的每条边 */</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">void</span> <span class="token function">MiniSpanTree_Prim</span><span class="token punctuation">(</span>AdjMatrix gn<span class="token punctuation">,</span> VertexData u<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>	k<span class="token operator">=</span><span class="token function">LocateVertex</span><span class="token punctuation">(</span>gn<span class="token punctuation">,</span> u<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	closedge<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 初始化，U=&#123;u&#125; */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>gn<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>       <span class="token comment">/* 对 V-U 中的顶点 i，初始化 closedge [i]*/</span></pre></td></tr><tr><td data-num="11"></td><td><pre>		<span class="token keyword">if</span> <span class="token punctuation">(</span> i<span class="token operator">!=</span>k<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adjvex<span class="token operator">=</span>u<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>			closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost<span class="token operator">=</span>gn<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">/* 找 n-1 条边 (n= gn.vexnum) */</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>e<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span> e<span class="token operator">&lt;=</span>gn<span class="token punctuation">.</span>vexnum<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> e<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="17"></td><td><pre>		k0<span class="token operator">=</span><span class="token function">Minium</span><span class="token punctuation">(</span>closedge<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* closedge [k0] 中存有当前最小边 (u0,v0) 的信息 */</span></pre></td></tr><tr><td data-num="18"></td><td><pre>		u0<span class="token operator">=</span> closedge<span class="token punctuation">[</span>k0<span class="token punctuation">]</span><span class="token punctuation">.</span>adjvex<span class="token punctuation">;</span> <span class="token comment">/* u0∈U*/</span></pre></td></tr><tr><td data-num="19"></td><td><pre>		v0<span class="token operator">=</span> gn<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>k0<span class="token punctuation">]</span> <span class="token comment">/* v0∈V-U*/</span></pre></td></tr><tr><td data-num="20"></td><td><pre>	 	<span class="token function">printf</span><span class="token punctuation">(</span>u0<span class="token punctuation">,</span> v0<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 输出生成树的当前最小边 (u0,v0)*/</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	 	closedge<span class="token punctuation">[</span>k0<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment">/* 将顶点 v0 纳入 U 集合 */</span></pre></td></tr><tr><td data-num="22"></td><td><pre>	 	<span class="token keyword">for</span> <span class="token punctuation">(</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span>i<span class="token operator">&lt;</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token comment">/* 在顶点 v0 并入 U 之后，更新 closedge [i]*/</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	 		<span class="token keyword">if</span> <span class="token punctuation">(</span> gn<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>k0<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj <span class="token operator">&lt;</span>closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="24"></td><td><pre>                closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>lowcost<span class="token operator">=</span> gn<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>k0<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>				closedge<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adjvex<span class="token operator">=</span>v0<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>	 		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>2. 克鲁斯卡尔 (Kruskal) 算法</p><p>算法思想<br>①首先构造一个只有 n 个顶点但没有边的非连通图 T={V,}, 图中每个顶点自成一个连通分量。<br>②当在边集 E 中选到一条具有最小权值的边时，若该边的两个顶点落在 T 中不同的连通分量上，则将此边加入到生成树的边集合 T 中；否则将此边舍去，重新选择一条权值最小的边。<br>③如此重复下去，直到所有顶点在同一个连通分量上为止。此时的 T 即为所求。<br><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/20200514232913.png" alt=""></p><h2 id="5有向无环图应用"><a class="anchor" href="#5有向无环图应用">#</a> 5. 有向无环图应用</h2><p>有向无环图 (Directed Acyclic Graph):<br>是指一个无环的有向图，简称 DAG。有向无环图可用来描述工程或系统的进行过程，如一个工程的施工图、学生课程间的制约关系图等。</p><p>1. 拓扑排序 (Topological Sort):<br>用顶点表示活动，用弧表示活动间的优先关系的有向无环图，称为顶点表示活动的网 (Activity On Vertex Network), 简称为 AOV - 网。</p><p>拓扑排序的基本思想为：<br>(1) 从有向图中选一个无前驱的结点输出；<br>(2) 将此结点和以它为起点的边删除；<br>(3) 重复 (1)、(2)，直到不存在无前驱的结点；<br>(4) 若此时输出的结点数小于有向图中的顶点数，则说明有向图中存在回路，否则输出的顶点的顺序即为一个拓扑序列。</p><p>算法实现：</p><p>(1) 基于邻接矩阵表示的存储结构<br>A 为有向图 G 的邻接矩阵，则有：<br>找 G 中无前驱的结点 —— 在 A 中找到值全为 0 的列；<br>删除以 i 为起点的所有弧 —— 将矩阵中 i 对应的行全部置为 0。<br>算法步骤如下：<br>①取 1 作为第一新序号；<br>②找一个未新编号的、值全为 0 的列 j，若找到则转③；否则，若所有的列全部都编过号，排序结束；若有列未曾被编号，则该图中有回路；<br>③输出列号对应的顶点 j，把新序号赋给所找到的列；<br>④将矩阵中 j 对应的行全部置为 0;<br>⑤新序号加 1，转②；</p><p>(2) 基于邻接表的存储结构<br>(1) 首先求出各顶点的入度，并将入度为 0 的顶点入栈；<br>(2) 只要栈不空，则重复下面处理：<br>①将栈顶顶点 i 出栈并打印；<br>②将顶点 i 的每一个邻接点 k 的入度减 1，如果顶点 k 的入度变为 0，则将顶点 k 入栈。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 拓扑排序算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token function">TopoSort</span> <span class="token punctuation">(</span>AdjList G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="3"></td><td><pre>    Stack S<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>	<span class="token keyword">int</span> indegree<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> i<span class="token punctuation">,</span> count<span class="token punctuation">,</span> k<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> 	ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> 	<span class="token function">FindID</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span>indegree<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 求各顶点入度 */</span></pre></td></tr><tr><td data-num="8"></td><td><pre> 	<span class="token function">InitStack</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 初始化辅助栈 */</span></pre></td></tr><tr><td data-num="9"></td><td><pre> 	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre> 		<span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 将入度为 0 的顶点入栈 */</span></pre></td></tr><tr><td data-num="11"></td><td><pre> 	count<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre> 	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>		<span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span><span class="token operator">&amp;</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> 		<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span> G<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre> 		count<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">/* 输出 i 号顶点并计数 */</span></pre></td></tr><tr><td data-num="16"></td><td><pre> 		p<span class="token operator">=</span>G<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>		<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            k<span class="token operator">=</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> 			indegree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">/*i 号顶点的每个邻接点的入度减 1*/</span></pre></td></tr><tr><td data-num="20"></td><td><pre> 			<span class="token keyword">if</span><span class="token punctuation">(</span>indegree<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>S<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 若入度减为 0，则入栈 */</span></pre></td></tr><tr><td data-num="21"></td><td><pre>			p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="24"></td><td><pre> 	<span class="token keyword">if</span> <span class="token punctuation">(</span>count<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 该有向图含有回路 */</span></pre></td></tr><tr><td data-num="25"></td><td><pre> 	<span class="token keyword">else</span> <span class="token keyword">return</span><span class="token punctuation">(</span>Ok<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="27"></td><td><pre><span class="token comment">/* 求各顶点的入度 */</span></pre></td></tr><tr><td data-num="28"></td><td><pre><span class="token keyword">void</span> <span class="token function">FindID</span><span class="token punctuation">(</span> AdjList G<span class="token punctuation">,</span> <span class="token keyword">int</span> indegree<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="29"></td><td><pre>    <span class="token keyword">int</span> i<span class="token punctuation">;</span> ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>indegree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        p<span class="token operator">=</span>G<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>		<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>            indegree<span class="token punctuation">[</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="35"></td><td><pre>			p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre>	<span class="token punctuation">&#125;</span> </pre></td></tr><tr><td data-num="38"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>2. 关键路径<br>(理解)<br>通常用有向图来表示工程计划时有两种方法：<br>(1) 用顶点表示活动，用有向弧表示活动间的优先关系，即上节所讨论的 AOV 网。<br>(2) 用顶点表示事件，用弧表示活动，弧的权值表示活动所需要的时间。把用第二种方法构造的有向无环图叫做边表示活动的网 (Activity On Edge Network), 简称 AOE - 网。</p><p>源点：在 AOE 网中存在惟一的、入度为 0 的顶点；<br>汇点：存在惟一的、出度为 0 的顶点；<br>关键路径：从源点到汇点的<strong>最长路径</strong>的长度即为完成整个工程任务所需的时间。<br>关键活动：关键路径上的活动，这些活动中的任意一项活动未能按期完成，则整个工程的完成时间就要推迟。</p><p>在讨论关键路径算法之前，首先给出几个重要的定义：<br>(1) 事件 vi 的最早发生时间 ve (i)：从源点到顶点 vi 的最长路径的长度，叫做事件 vi 的最早发生时间。<br>(2) 事件 vi 的最晚发生时间 vl (i)：在保证汇点按其最早发生时间发生这一前提下，求事件 vi 的最晚发生时间。在求出 ve (i) 的基础上，可从汇点开始，按逆拓扑顺序向源点递推，求出 vl (i);<br>(3) 活动 ai 的最早开始时间 e (i)：如果活动 ai 对应的弧为，则 e (i) 等于从源点到顶点 j 的最长路径的长度，即：e (i)=ve (j)<br>(4) 活动 ai 的最晚开始时间 l (i)：如果活动 ai 对应的弧为，其持续时间为 dut () 则有：l (i)=vl (k)- dut () 即在保证事件 vk 的最晚发生时间为 vl (k) 的前提下，活动 ai 的最晚开始时间为 l (i)。<br>(5) 活动 ai 的松弛时间 (时间余量)：ai 的最晚开始时间与 ai 的最早开始时间之差：l (i)- e (i)。显然，松弛时间 (时间余量) 为 0 的活动为关键活动。</p><p>求关键路径的基本步骤如下：<br>①对图中顶点进行拓扑排序，在排序过程中按拓扑序列求出每个事件的最早发生时间 ve (i)；<br>②按逆拓扑序列求每个事件的最晚发生时间 vl (i)；<br>③求出每个活动 ai 的最早开始时间 e (i) 和最晚发生时间 l (i)；<br>④找出 e (i)=l (i) 的活动 ai，即为关键活动。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 关键路径算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">int</span> <span class="token function">CriticalPath</span><span class="token punctuation">(</span>AdjList G<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    ArcNode <span class="token operator">*</span>p<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre> 	<span class="token keyword">int</span> i<span class="token punctuation">,</span>j<span class="token punctuation">,</span>k<span class="token punctuation">,</span>dut<span class="token punctuation">,</span>ei<span class="token punctuation">,</span>li<span class="token punctuation">;</span> <span class="token keyword">char</span> tag<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>	<span class="token keyword">int</span> vl<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">/* 每个顶点的最迟发生时间 */</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	Stack T<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="7"></td><td><pre> 	<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">TopoOrder</span><span class="token punctuation">(</span>G<span class="token punctuation">,</span> <span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">(</span>Error<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">/* 将各顶点事件的最迟发生时间初始化为汇点的最早发生时间 */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token keyword">for</span><span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>		vl<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>ve<span class="token punctuation">[</span>G<span class="token punctuation">.</span>vexnum<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> </pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">/* 按逆拓扑顺序求各顶点的 vl 值 */</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	<span class="token keyword">while</span><span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">IsEmpty</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="14"></td><td><pre> 		<span class="token function">Pop</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>T<span class="token punctuation">,</span><span class="token operator">&amp;</span>j<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>		p<span class="token operator">=</span>G<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>            k<span class="token operator">=</span>p<span class="token operator">-></span>adjvex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>            dut<span class="token operator">=</span>p<span class="token operator">-></span>weight<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> 			<span class="token keyword">if</span><span class="token punctuation">(</span>vl<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span>dut<span class="token operator">&lt;</span>vl<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> vl<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span> vl<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span>dut<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre> 			p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre> 		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="22"></td><td><pre> 	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">/* 求 ei,li 和关键活动 */</span></pre></td></tr><tr><td data-num="24"></td><td><pre>	<span class="token keyword">for</span><span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>G<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> </pre></td></tr><tr><td data-num="25"></td><td><pre>  		p<span class="token operator">=</span>G<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>firstarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>		<span class="token keyword">while</span><span class="token punctuation">(</span>p<span class="token operator">!=</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>    	    k<span class="token operator">=</span>p<span class="token operator">-></span>Adjvex<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>    	    dut<span class="token operator">=</span>p<span class="token operator">-></span>Info<span class="token punctuation">.</span>weight<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> 			ei<span class="token operator">=</span>ve<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>li<span class="token operator">=</span>vl<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">-</span>dut<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="30"></td><td><pre>			tag <span class="token operator">=</span> <span class="token punctuation">(</span>ei<span class="token operator">==</span>li<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token char">'*'</span> <span class="token operator">:</span> <span class="token char">' '</span> <span class="token punctuation">;</span> <span class="token comment">/* 标记并输出关键活动 */</span></pre></td></tr><tr><td data-num="31"></td><td><pre>			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c,%c,%d,%d,%d,%c\n"</span><span class="token punctuation">,</span>G<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span>G<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span>dut<span class="token punctuation">,</span>ei<span class="token punctuation">,</span>li<span class="token punctuation">,</span>ta</pre></td></tr><tr><td data-num="32"></td><td><pre>g<span class="token punctuation">)</span><span class="token punctuation">;</span>	</pre></td></tr><tr><td data-num="33"></td><td><pre> 			p<span class="token operator">=</span>p<span class="token operator">-></span>nextarc<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre> 		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="35"></td><td><pre> 	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token keyword">return</span><span class="token punctuation">(</span>Ok<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token comment">/*CriticalPath*/</span></pre></td></tr></table></figure><h2 id="6最短路径"><a class="anchor" href="#6最短路径">#</a> 6. 最短路径</h2><p>1、带权图的最短路径：求两个顶点间长度最短的路径。其中：路径长度不是指路径上边数的总和，而是指路径上各边的权值总和。路径长度的具体含义取决于边上权值所代表的意义。<br>2、单源最短路径问题：已知有向带权图 (简称有向网) G=(V，E)，找出从某个源点 s∈V 到 V 中其余各顶点的最短路径。</p><p>3. 迪杰斯特拉 (Dijkstra) 算法求单源最短路径<br>设 S 为最短距离已确定的顶点集 (看作红点集)，V-S 是最短距离尚未确定的顶点集 (看作绿点集)。<br>①初始化<br>初始化时，只有源点 s 的最短距离是已知的 (SD (s)=0)，故红点集 S={s}，蓝点集为空。<br>②重复以下工作，按路径长度递增次序产生各顶点最短路径　在当前蓝点集中选择一个最短距离最小的蓝点来扩充红点集，以保证算法按路径长度递增的次序产生各顶点的最短路径。当蓝点集中仅剩下最短距离为∞的蓝点，或者所有蓝点已扩充到红点集时，s 到所有顶点的最短路径就求出来了。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 图的最短路径算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">define</span> <span class="token macro-name">INFINITY</span> <span class="token expression"><span class="token number">32768</span> </span><span class="token comment">/* 表示极大值，即∞*/</span></span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token keyword">typedef</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> WeightType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">typedef</span> WeightType AdjType<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">typedef</span> SeqList VertexSet<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">/* path [i] 中存放顶点 i 的当前最短路径。dist [i] 中存放顶点 i 的当前最短路径长度 */</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token keyword">void</span> <span class="token function">ShortestPath_DJS</span><span class="token punctuation">(</span>AdjMatrix g<span class="token punctuation">,</span> <span class="token keyword">int</span> v0<span class="token punctuation">,</span>WeightType dist<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">,</span>VertexSet path<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	VertexSet s<span class="token punctuation">;</span> <span class="token comment">/* s 为已找到最短路径的终点集合 */</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">/* 初始化 dist [i] 和 path [i] */</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnum <span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token function">InitList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>		dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>g<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	 	<span class="token keyword">if</span> <span class="token punctuation">(</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> INFINITY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>            <span class="token function">AddTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* AddTail 是表尾添加操作 */</span></pre></td></tr><tr><td data-num="15"></td><td><pre>			<span class="token function">AddTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="16"></td><td><pre>	 	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	<span class="token function">InitList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>	<span class="token function">AddTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>v0<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* 将 v0 看成第一个已找到最短路径的终点 */</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">/* 求 v0 到其余 n-1 个顶点的最短路径 (n= g.vexnum)*/</span></pre></td></tr><tr><td data-num="21"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span> t <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> t<span class="token operator">&lt;=</span>g<span class="token punctuation">.</span>vexnum<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> t<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="22"></td><td><pre>		min<span class="token operator">=</span> INFINITY<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="24"></td><td><pre>			<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span> <span class="token function">Member</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;</span>min <span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="25"></td><td><pre>                k <span class="token operator">=</span>i<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="26"></td><td><pre>                min<span class="token operator">=</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="27"></td><td><pre>            <span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="28"></td><td><pre>		<span class="token function">AddTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>s<span class="token punctuation">,</span> g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre>         <span class="token comment">/* 修正 dist [i], i∈V-S*/</span></pre></td></tr><tr><td data-num="30"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="31"></td><td><pre>	 	<span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">Member</span><span class="token punctuation">(</span>g<span class="token punctuation">.</span>vertex <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> s<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> g<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token operator">!=</span> INFINITY	<span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span> g<span class="token punctuation">.</span>arcs <span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token operator">&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="32"></td><td><pre>			dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span> g<span class="token punctuation">.</span>arcs <span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre>			path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>path<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="34"></td><td><pre>	 		<span class="token function">AddTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">.</span>vertex <span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">/* path[i]=path[k]∪&#123;Vi&#125; */</span></pre></td></tr><tr><td data-num="35"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="36"></td><td><pre>	<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="37"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>4. 求任意一对顶点间的最短路<br>佛罗伊德算法<br>设图 g 用邻接矩阵法表示，求图 g 中任意一对顶点 vi、、vj 间的的最短路径。(-1) 将 vi 到 vj 的最短的路径长度初始化为 g.arcs [i][j].adj，然后进行如下 n 次比较和修正：<br>(0) 在 vi、vj 间加入顶点 v0，比较 (vi,v0,vj) 和 (vi,vj) 的路径的长度，取其中较短的路径作为 vi 到 vj 的且中间顶点号不大于 0 的最短路径。<br>(1) 在 vi、vj 间加入顶点 v1，得到 (vi,…， v1) 和 (v1,…， vj)，其中 (vi,…,v1) 是 vi 到 v1 的且中间顶点号不大于 0 的最短路径，(v1,…,vj) 是 v1 到 vj 的且中间顶点号不大于 0 的最短路径，这两条路径在上一步中已求出。将 (vi,…,v1,…,vj) 与上一步已求出的且 vi 到 vj 中间顶点号不大于 0 的最短路径比较，取其中较短的路径作为 vi 到 vj 的且中间顶点号不大于 1 的最短路径。<br>(2) 在 vi、vj 间加入顶点 v2，得 (vi,…,v2) 和 (v2,…,vj)，其中 (vi,…,v2) 是 vi 到 v2 的且中间顶点号不大于 1 的最短路径，(v2,…,vj) 是 v2 到 vj 的且中间顶点号不大于 1 的最短路径，这两条路径在上一步中已求出。将 (vi,…,v2,…,vj) 与上一步已求出的且 vi 到 vj 中间顶点号不大于 1 的最短路径比较，取其中较短的路径作为 vi 到 vj 的且中间顶点号不大于 2 的最短路径。<br>………<br>依次类推，经过 n 次比较和修正，在第 (n-1) 步，将求得 vi 到 vj 的且中间顶点号不大于 n-1 的最短路径，这必是从 vi 到 vj 的最短路径。图 g 中所有顶点偶对 vi、vj 间的最短路径长度对应一个 n 阶方阵 D。在上述 n+1 步中， D 的值不断变化，对应一个 n 阶方阵序列。</p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 弗洛伊德算法</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">typedef</span> SeqList VertexSet<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token comment">/* g 为带权有向图的邻接矩阵表示法， path [i][j] 为 vi 到 vj 的当前最短路径，dist [i][j] 为 vi 到 vj 的当前最短路径长度 */</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token keyword">void</span> <span class="token function">ShortestPath_Floyd</span><span class="token punctuation">(</span>AdjMatrix g<span class="token punctuation">,</span>WeightType dist <span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span> <span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span><span class="token punctuation">,</span>VertexSet path<span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span> <span class="token punctuation">[</span>MAX_VERTEX_NUM<span class="token punctuation">]</span> <span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token comment">/* 初始化 dist [i][j] 和 path [i][j] */</span></pre></td></tr><tr><td data-num="6"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnumn<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> </pre></td></tr><tr><td data-num="7"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span>j <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>	 		<span class="token function">InitList</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>			dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>g<span class="token punctuation">.</span>arcs<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span>adj<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>	 		<span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>INFINITY<span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>                <span class="token function">AddTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>				<span class="token function">AddTail</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>path<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> g<span class="token punctuation">.</span>vertex<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>	 		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>		<span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>	<span class="token keyword">for</span> <span class="token punctuation">(</span>k <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>k<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>k<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="16"></td><td><pre>		<span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="17"></td><td><pre>	 		<span class="token keyword">for</span> <span class="token punctuation">(</span>j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>g<span class="token punctuation">.</span>vexnum<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="18"></td><td><pre>	 			<span class="token keyword">if</span> <span class="token punctuation">(</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="19"></td><td><pre>                    dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span>dist<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token operator">+</span>dist<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="20"></td><td><pre>			 		paht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">JoinList</span><span class="token punctuation">(</span>paht<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">,</span> paht<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="21"></td><td><pre>				<span class="token punctuation">&#125;</span> <span class="token comment">/* JoinList 是合并线性表操作 */</span></pre></td></tr><tr><td data-num="22"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>7. 总结<br>(1) 基本概念：<br>图中顶点间的关系可以任意的，因此图是最复杂的非线性结构，它的表达力强。图具有有向图、无向图、连通图、强连通图、完全图、赋权图等多种类型。<br>(2) 图的存储结构：<br>图的存储方式一般有两类，用边的集合方式有邻接矩阵，链接方式有邻接表、十字链表、邻接多重表。邻接矩阵和邻接表是两种常用的存储结构，适用于有向图 (网) 和无向图 (网) 表示与处理。<br>(3) 图的基本操作：由于图中结点间可以是多对多的关系，为实现图的遍历必须设置访问标志数组，以防止走回路或未访问到。图的遍历规律有两种：深度优先遍历 DFS 和广度优先遍历 BFS。可用用邻接矩阵和邻接表实现深度优先遍历和广度优先遍历算法。深度优先遍历算法是以递归技术为支持，而广度优先遍历算法是以队列技术为支持。<br>(4) 图的应用：图的遍历算法是图应用的重要基础。求解生成树、最小生成树、连通分量，拓扑排序、关键路径、单源最短路径及所有顶点之间的最短路径的重要算法应用。</p><div class="tags"><a href="/tags/dataStructure/" rel="tag"><i class="ic i-tag"></i> 数据结构</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2024-10-01 23:06:02" itemprop="dateModified" datetime="2024-10-01T23:06:02+08:00">2024-10-01</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Twelveeee <i class="ic i-at"><em>@</em></i>十二的编程笔记</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.twelveeee.top/2020/DataStructure/Graph/intro/" title="图">https://blog.twelveeee.top/2020/DataStructure/Graph/intro/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2020/DataStructure/Tree/binary%20tree/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;twelveeee-note.oss-cn-beijing.aliyuncs.com&#x2F;Image&#x2F;img&#x2F;bgimg_48.webp" title="二叉树"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 树</span><h3>二叉树</h3></a></div><div class="item right"><a href="/2020/Linux/Linux%20text%20editor/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;twelveeee-note.oss-cn-beijing.aliyuncs.com&#x2F;Image&#x2F;img&#x2F;bgimg_80.webp" title="Linux文本编辑器"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Linux 基础</span><h3>Linux文本编辑器</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">1. 定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.</span> <span class="toc-text">2. 存储结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.3.</span> <span class="toc-text">3. 图的遍历</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4%E5%9B%BE%E7%9A%84%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">4. 图的连通性</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5%E6%9C%89%E5%90%91%E6%97%A0%E7%8E%AF%E5%9B%BE%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.</span> <span class="toc-text">5. 有向无环图应用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.</span> <span class="toc-text">6. 最短路径</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2020/DataStructure/Graph/intro/" rel="bookmark" title="图">图</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Twelveeee" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Twelveeee</p><div class="description" itemprop="description">十二的编程笔记</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">113</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">30</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R3ZWx2ZWVlZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;twelveeee"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnR3ZWx2ZWVlZTEyQGdtYWlsLmNvbQ==" title="mailto:twelveeee12@gmail.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cudHJhdmVsbGluZ3MuY24vZ28uaHRtbA=="><i class="ic i-paper-plane"></i>开往</span></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2020/DataStructure/Tree/binary%20tree/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2020/Linux/Linux%20text%20editor/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/" title="分类于 GO">GO</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/Lib/" title="分类于 Lib">Lib</a></div><span><a href="/2023/Go/Lib/io/" title="Go 标准库源码解析-IO操作">Go 标准库源码解析-IO操作</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/%E6%9F%A5%E6%89%BE/" title="分类于 查找">查找</a></div><span><a href="/2020/DataStructure/Search/intro/" title="查找的基本概念">查找的基本概念</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/algorithm2023/" title="分类于 算法训练 2023">算法训练 2023</a></div><span><a href="/2023/AlgorithmCamp2023/03_array/" title="03-数组和双指针思想">03-数组和双指针思想</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/" title="分类于 GO">GO</a></div><span><a href="/2023/Go/go%20built-in%20data%20types/" title="Go 内置数据类型">Go 内置数据类型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Search/" title="分类于 Search">Search</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Search/Elasticsearch/" title="分类于 Elasticsearch">Elasticsearch</a></div><span><a href="/2021/Search/ElasticSearch/basic_usage/" title="Elasticsearch 基础使用">Elasticsearch 基础使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Project/" title="分类于 Project">Project</a></div><span><a href="/2024/Project/cloudflare-docker-proxy/" title="搭建使用Cloudflare Worker的Docker 镜像">搭建使用Cloudflare Worker的Docker 镜像</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/" title="分类于 GO">GO</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/Lib/" title="分类于 Lib">Lib</a></div><span><a href="/2023/Go/Lib/zerolog/" title="Go zerolog 使用">Go zerolog 使用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/C/" title="分类于 C">C</a></div><span><a href="/2020/C/C%20note/" title="C语言个人笔记">C语言个人笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/" title="分类于 GO">GO</a></div><span><a href="/2023/Go/go%20generic/" title="Go 泛型">Go 泛型</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/algorithm2023/" title="分类于 算法训练 2023">算法训练 2023</a></div><span><a href="/2023/AlgorithmCamp2023/12_String/" title="12-字符串">12-字符串</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2024</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Twelveeee @ Twelveeee</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">578k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">8:45</span></div><div class="beian-by"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">闽ICP备20004781号</a></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2020/DataStructure/Graph/intro/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(t){return t.includes("#")},function(t){return new RegExp(LOCAL.path+"$").test(t)}]}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?30195a9a0f4d22cd45e9d770a10c683f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F27X623LWT"></script><script data-pjax>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-F27X623LWT")</script>--></body></html>