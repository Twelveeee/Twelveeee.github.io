<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" title="十二的编程笔记" href="https://blog.twelveeee.top/rss.xml"><link rel="alternate" type="application/atom+xml" title="十二的编程笔记" href="https://blog.twelveeee.top/atom.xml"><link rel="alternate" type="application/json" title="十二的编程笔记" href="https://blog.twelveeee.top/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="MySQL"><link rel="canonical" href="https://blog.twelveeee.top/2023/Database/mysql_detail/"><title>MySQL 详解 - MySQL - Database - 计算机科学 | Twelveeee = 十二的编程笔记 = hello world</title><meta name="generator" content="Hexo 6.3.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">MySQL 详解</h1><div class="meta"><span class="item" title="创建时间：2023-11-07 12:00:00"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2023-11-07T12:00:00+08:00">2023-11-07</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>20k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>18 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Twelveeee</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_87.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_38.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_90.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_70.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_97.webp"></li><li class="item" data-background-image="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/img/bgimg_6.webp"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/" itemprop="item" rel="index" title="分类于 计算机科学"><span itemprop="name">计算机科学</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/Database/" itemprop="item" rel="index" title="分类于 Database"><span itemprop="name">Database</span></a><meta itemprop="position" content="2"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/computerScience/Database/MySQL/" itemprop="item" rel="index" title="分类于 MySQL"><span itemprop="name">MySQL</span></a><meta itemprop="position" content="3"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://blog.twelveeee.top/2023/Database/mysql_detail/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="Twelveeee"><meta itemprop="description" content="hello world, 十二的编程笔记"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="十二的编程笔记"></span><div class="body md" itemprop="articleBody"><h1 id="mysql"><a class="anchor" href="#mysql">#</a> MySQL</h1><p><span class="exturl" data-url="aHR0cHM6Ly94aWFvbGluY29kaW5nLmNvbS9teXNxbC8=">图解 mysql</span></p><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuaXNrbS5vcmcvbXlzcWw1Ni9pbmRleC5odG1s">mysql 源码</span></p><h1 id="数据查询过程"><a class="anchor" href="#数据查询过程">#</a> 数据查询过程</h1><ul><li>连接器：建立连接，管理连接、校验用户身份；</li><li>查询缓存：查询语句如果命中查询缓存则直接返回，否则继续往下执行。MySQL 8.0 已删除该模块；</li><li>解析 SQL，通过解析器对 SQL 查询语句进行词法分析、语法分析，然后构建语法树，方便后续模块读取表名、字段、语句类型；</li><li>执行 SQL：执行 SQL 共有三个阶段：<ul><li>预处理阶段：检查表或字段是否存在；将 <code>select *</code> 中的 <code>*</code> 符号扩展为表上的所有列。</li><li>优化阶段：基于查询成本的考虑， 选择查询成本最小的执行计划；</li><li>执行阶段：根据执行计划执行 SQL 查询语句，从存储引擎读取记录，返回给客户端；</li></ul></li></ul><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311072255077.png" alt="查询语句执行流程"></p><h2 id="连接"><a class="anchor" href="#连接">#</a> 连接</h2><ul><li>与客户端进行 TCP 三次握手建立连接；</li><li>校验客户端的用户名和密码，如果用户名或密码不对，则会报错；</li><li>如果用户名和密码都对了，会读取该用户的权限，然后后面的权限逻辑判断都基于此时读取到的权限；</li></ul><p><strong>最大空闲时长</strong>：MySQL 定义了空闲连接的<strong>最大空闲时长</strong>，由 <code>wait_timeout</code> 参数控制的，默认值是 8 小时（28880 秒），如果空闲连接超过了这个时间，连接器就会自动将它断开。</p><p><strong>连接数限制</strong>：MySQL 服务支持的最大连接数由 max_connections 参数控制，超过这个值系统就会拒绝接下来的连接请求，并报错提示 “Too many connections”。</p><p><strong>短连接和长连接</strong></p><figure class="highlight c"><figcaption data-lang="c"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">// 短连接</span></pre></td></tr><tr><td data-num="2"></td><td><pre>连接 mysql 服务（TCP 三次握手）</pre></td></tr><tr><td data-num="3"></td><td><pre>执行sql</pre></td></tr><tr><td data-num="4"></td><td><pre>断开 mysql 服务（TCP 四次挥手）</pre></td></tr><tr><td data-num="5"></td><td><pre></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token comment">// 长连接</span></pre></td></tr><tr><td data-num="7"></td><td><pre>连接 mysql 服务（TCP 三次握手）</pre></td></tr><tr><td data-num="8"></td><td><pre>执行sql</pre></td></tr><tr><td data-num="9"></td><td><pre>执行sql</pre></td></tr><tr><td data-num="10"></td><td><pre>执行sql</pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="12"></td><td><pre>断开 mysql 服务（TCP 四次挥手）</pre></td></tr></table></figure><p>使用长连接的好处就是可以减少建立连接和断开连接的过程，所以一般是推荐使用长连接。</p><p>但是，使用长连接后可能会占用内存增多，因为 MySQL 在执行查询过程中临时使用内存管理连接对象，这些连接对象资源只有在连接断开时才会释放。如果长连接累计很多，将导致 MySQL 服务占用内存太大，有可能会被系统强制杀掉，这样会发生 MySQL 服务异常重启的现象。</p><p><strong>Q&amp;A</strong></p><p>如何查看 mysl 被多少客户端链接了</p><p><code>show processlist</code></p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311072255685.png" alt="image-20230804154950897"></p><p>怎么解决长连接占用内存的问题？</p><p>第一种，<strong>定期断开长连接</strong>。既然断开连接后就会释放连接占用的内存资源，那么我们可以定期断开长连接。</p><p>第二种，<strong>客户端主动重置连接</strong>。MySQL 5.7 版本实现了 <code>mysql_reset_connection()</code> 函数的接口，注意这是接口函数不是命令，那么当客户端执行了一个很大的操作后，在代码里调用 mysql_reset_connection 函数来重置连接，达到释放内存的效果。这个过程不需要重连和重新做权限验证，但是会将连接恢复到刚刚创建完时的状态。</p><h2 id="查询缓存"><a class="anchor" href="#查询缓存">#</a> 查询缓存</h2><p>查询语句会先查询 查询缓存 (Query Cache)，key-value 结构 key 为 SQL，value 为结果。</p><p>如果表有更新操作，查询缓存会被清空。</p><p>MySQL 8.0 及之后版本已经删除了查询缓存。</p><p>对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 <code>DEMAND</code> 。</p><p>查询缓存是 server 层的，并不是 Innodb 存储引擎中的 buffer pool</p><h2 id="解析"><a class="anchor" href="#解析">#</a> 解析</h2><p>解析器会做如下两件事情。</p><p><strong>词法分析</strong>。MySQL 会根据你输入的字符串识别出关键字出来，构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。</p><p><strong>语法分析</strong>。根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</p><p>如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错。</p><p>表不存在或者字段不存在，并不是在解析器里做的。解析器只负责构建语法树和检查语法，但是不会去查表或者字段存不存在。</p><h2 id="执行"><a class="anchor" href="#执行">#</a> 执行</h2><p>三个阶段</p><ul><li>prepare 阶段，预处理阶段；</li><li>optimize 阶段，优化阶段；</li><li>execute 阶段，执行阶段；</li></ul><h3 id="预处理器"><a class="anchor" href="#预处理器">#</a> 预处理器</h3><ul><li>检查 SQL 查询语句中的表或者字段是否存在；</li><li>将 <code>select *</code> 中的 <code>*</code> 符号，扩展为表上的所有列；</li></ul><h3 id="优化器"><a class="anchor" href="#优化器">#</a> 优化器</h3><p><strong>优化器主要负责将 SQL 查询语句的执行方案确定下来</strong>，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。</p><p>以在查询语句最前面加个 <code>explain</code> 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引。</p><p>索引后面再讲</p><h3 id="执行器"><a class="anchor" href="#执行器">#</a> 执行器</h3><p>三种方式执行过程</p><p><strong>主键索引查询</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为 InnoDB 引擎索引查询的接口，把条件 <code>id = 1</code> 交给存储引擎，<strong>让存储引擎定位符合条件的第一条记录</strong>。</li><li>存储引擎通过主键索引的 B+ 树结构定位到 id = 1 的第一条记录，如果记录是不存在的，就会向执行器上报记录找不到的错误，然后查询结束。如果记录是存在的，就会将记录返回给执行器；</li><li>执行器从存储引擎读到记录后，接着判断记录是否符合查询条件，如果符合则发送给客户端，如果不符合则跳过该记录。</li><li>执行器查询的过程是一个 while 循环，所以还会再查一次，但是这次因为不是第一次查询了，所以会调用 read_record 函数指针指向的函数，因为优化器选择的访问类型为 const，这个函数指针被指向为一个永远返回 - 1 的函数，所以当调用该函数的时候，执行器就退出循环，也就是结束查询了。</li></ul><p><strong>全表扫描</strong></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> product <span class="token keyword">where</span> name <span class="token operator">=</span> <span class="token string">'iphone'</span><span class="token punctuation">;</span></pre></td></tr></table></figure><ul><li>执行器第一次查询，会调用 read_first_record 函数指针指向的函数，因为优化器选择的访问类型为 all，这个函数指针被指向为 InnoDB 引擎全扫描的接口，<strong>让存储引擎读取表中的第一条记录</strong>；</li><li>执行器会判断读到的这条记录的 name 是不是 iphone，如果不是则跳过；如果是则将记录发给客户端。Server 层每从存储引擎读到一条记录就会发送给客户端。客户端等查询语句查询完成后，才会显示出所有的记录</li><li>一直重复上述过程，直到存储引擎把表中的所有记录读完，然后向执行器（Server 层） 返回了读取完毕的信息；</li><li>执行器收到存储引擎报告的查询完毕的信息，退出循环，停止查询。</li></ul><p><strong>索引下推 (index condition pushdown)</strong></p><p>MySQL 5.6 推出的查询优化策略</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment"># idx_age_reward</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user  <span class="token keyword">where</span> age <span class="token operator">></span> <span class="token number">20</span> <span class="token operator">and</span> reward <span class="token operator">=</span> <span class="token number">100000</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>不使用索引下推执行器与存储引擎的执行流程：</p><ul><li>定位到最左匹配的第一条记录， age &gt; 20 的第一条记录。</li><li>获取所有满足最左匹配的数据，拿出主键，然后进行回表，再把完整的记录返回给 Server 层，Server 判断 reward 是否满足条件，否则跳过。</li><li>重复操作，直到存储引擎把表中的所有符合条件的记录读完。</li></ul><p>使用索引下推执行器与存储引擎的执行流程：</p><ul><li>定位到最左匹配的第一条记录， age &gt; 20 的第一条记录。</li><li>获取所有满足最左匹配的数据，判断 reward 是否满足条件，如果不成立则抛弃，如果成立则回表，将记录返回给 Server 层。</li><li>重复操作，直到存储引擎把表中的所有符合条件的记录读完。</li></ul><p>当组合索引满足最左匹配，但是遇到非等值判断时匹配停止。进行索引下推，由存储引擎过滤剩下的组合索引条件，减少回表数据。</p><h1 id="数据存储格式"><a class="anchor" href="#数据存储格式">#</a> 数据存储格式</h1><p>文件存放目录</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre>mysql<span class="token operator">></span> <span class="token keyword">SHOW</span> VARIABLES <span class="token operator">LIKE</span> <span class="token string">'datadir'</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token operator">+</span><span class="token comment">---------------+-----------------+</span></pre></td></tr><tr><td data-num="3"></td><td><pre><span class="token operator">|</span> Variable_name <span class="token operator">|</span> <span class="token keyword">Value</span>           <span class="token operator">|</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token operator">+</span><span class="token comment">---------------+-----------------+</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token operator">|</span> datadir       <span class="token operator">|</span> <span class="token operator">/</span>var<span class="token operator">/</span>lib<span class="token operator">/</span>mysql<span class="token operator">/</span> <span class="token operator">|</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token operator">+</span><span class="token comment">---------------+-----------------+</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span> <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span></pre></td></tr></table></figure><figure class="highlight bash"><figcaption data-lang="bash"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token punctuation">[</span>root@root ~<span class="token punctuation">]</span><span class="token comment">#ls /var/lib/mysql/my_test</span></pre></td></tr><tr><td data-num="2"></td><td><pre>db.opt  </pre></td></tr><tr><td data-num="3"></td><td><pre>t_order.frm  </pre></td></tr><tr><td data-num="4"></td><td><pre>t_order.ibd</pre></td></tr></table></figure><ul><li>db.opt，用来存储当前数据库的默认字符集和字符校验规则。</li><li>t_order.frm ，t_order 的<strong>表结构</strong>。</li><li>t_order.ibd，t_order 的<strong>表数据</strong>会保存在这个文件。表数据既可以存在共享表空间文件（文件名：ibdata1）里，也可以存放在独占表空间文件（文件名：表名字.ibd）。这个行为是由参数 innodb_file_per_table 控制的，若设置了参数 innodb_file_per_table 为 1，则会将存储的数据、索引等信息单独存储在一个独占表空间，从 MySQL 5.6.6 版本开始，它的默认值就是 1 了，因此从这个版本之后， MySQL 中每一张表的数据都存放在一个独立的 .ibd 文件。</li></ul><h2 id="表空间文件的结构"><a class="anchor" href="#表空间文件的结构">#</a> 表空间文件的结构</h2><p><strong>表空间由段（segment）、区（extent）、页（page）、行（row）组成</strong>，InnoDB 存储引擎的逻辑存储结构大致如下图：</p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311072255688.png" alt="img"></p><p><strong>行（row）</strong></p><p>数据库表中的记录都是按行（row）进行存放的，每行记录根据不同的行格式，有不同的存储结构。</p><p><strong>页（page）</strong></p><p>innoDB 的数据是按「页」为单位来读写的。<br><strong>默认每个页的大小为 16KB</strong>，最多能保证 16KB 的连续存储空间。<br>页是 InnoDB 存储引擎磁盘管理的最小单元，意味着数据库每次读写都是以 16KB 为单位的，一次最少从磁盘中读取 16K 的内容到内存中，一次最少把内存中的 16K 内容刷新到磁盘中。</p><p>一行的字节大小不能超过数据页的大小，当一行的字节大小超过数据页的大小时，这个行就无法存储在单个数据页中，这被称为行溢出（<strong>row overflow</strong>）。</p><p>页的类型有很多，常见的有数据页、undo 日志页、溢出页等等。数据表中的行记录是用「数据页」来管理的。</p><p><strong>区（extent）</strong></p><p>区是一组连续「页」的集合。</p><p>每个区的大小通常是多个数据页的大小的倍数，这个倍数可以根据具体的配置进行设置。例如，在 InnoDB 存储引擎中，默认情况下，一个区的大小为 1MB，而一个数据页的大小为 16KB。因此，一个区包含 64 个数据页。</p><p>区的主要目的是减少磁盘 IO 操作的次数。当 MySQL 需要分配新的存储空间来存储数据时，它会以区为单位进行分配。这样，相对于每次只分配一个数据页，分配一个区可以减少磁盘 IO 操作的次数，提高性能。</p><p>区还有助于提高数据的连续性。由于区是一组连续的数据页，当数据被存储在区中时，它们在磁盘上的物理位置也是连续的。这有助于提高数据的访问效率，减少磁盘寻道的开销。</p><p><strong>段（segment）</strong></p><p>表空间是由各个段（segment）组成的，段是由多个区（extent）组成的。段一般分为数据段、索引段和回滚段等。</p><ul><li>索引段：存放 B + 树的非叶子节点的区的集合；</li><li>数据段：存放 B + 树的叶子节点的区的集合；</li><li>回滚段：存放的是回滚数据的区的集合；</li></ul><h2 id="行格式"><a class="anchor" href="#行格式">#</a> 行格式</h2><p>行格式（row_format），就是一条记录的存储结构。</p><p>InnoDB 提供了 4 种行格式，分别是 Redundant、Compact、Dynamic 和 Compressed 行格式。</p><ul><li>Redundant 是很古老的行格式了， MySQL 5.0 版本之前用的行格式，现在基本没人用了。</li><li>Compact 是一种紧凑的行格式，设计的初衷就是为了让一个数据页中可以存放更多的行记录，从 MySQL 5.1 版本之后，行格式默认设置成 Compact。</li><li>Dynamic 和 Compressed 两个都是紧凑的行格式，它们的行格式都和 Compact 差不多，因为都是基于 Compact 改进一点东西。从 MySQL5.7 版本之后，默认使用 Dynamic 行格式。</li></ul><p><strong>COMPACT 行格式</strong></p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311072255138.png" alt="img"></p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>t_user<span class="token punctuation">`</span></span> <span class="token punctuation">(</span></pre></td></tr><tr><td data-num="2"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="3"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="4"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>phone<span class="token punctuation">`</span></span> <span class="token keyword">VARCHAR</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="5"></td><td><pre>  <span class="token identifier"><span class="token punctuation">`</span>age<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span></pre></td></tr><tr><td data-num="6"></td><td><pre>  <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">USING</span> <span class="token keyword">BTREE</span></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span> <span class="token operator">=</span> <span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARACTER</span> <span class="token keyword">SET</span> <span class="token operator">=</span> ascii ROW_FORMAT <span class="token operator">=</span> COMPACT<span class="token punctuation">;</span></pre></td></tr></table></figure><p>一条完整的记录分为「记录的额外信息」和「记录的真实数据」两个部分</p><h3 id="记录的额外信息"><a class="anchor" href="#记录的额外信息">#</a> 记录的额外信息</h3><ol><li><strong>变长字段长度列表</strong><br>变长字段的真实数据占用的字节数<br>如果是 NULL，则不会保存变长字段的长度<br>如果没有变长之短，则不会有变长字段长度列表</li><li><strong>NULL 值列表</strong><br>记录真实值为 NULL 的值<br>如果存在允许 NULL 值的列，则每个列对应一个二进制位（bit），二进制位按照列的顺序逆序排列。<br>如果一个字节存不下 NULL 值列表，则会扩增到两个字节。<br>当所有字段都是 NOT NULL，则不会有 NULL 值列表。</li><li><strong>记录头信息</strong><br>这几个比较重要<br><strong>delete_mask</strong> ：标识此条数据是否被删除。从这里可以知道，我们执行 detele 删除记录的时候，并不会真正的删除记录，只是将这个记录的 delete_mask 标记为 1。<br><strong>next_record</strong>：下一条记录的位置。指向的是下一条记录的「记录头信息」和「真实数据」之间的位置，这样的好处是向左读就是记录头信息，向右读就是真实数据，比较方便。<br><strong>record_type</strong>：表示当前记录的类型，0 表示普通记录，1 表示 B + 树非叶子节点记录，2 表示最小记录，3 表示最大记录</li></ol><p>额外信息大部分都是<strong>逆序</strong>存放。这样的好处是向左读就是记录头信息，向右读就是真实数据</p><h3 id="记录的真实数据"><a class="anchor" href="#记录的真实数据">#</a> 记录的真实数据</h3><p>记录真实数据部分除了我们定义的字段，还有三个隐藏字段，分别为：row_id、trx_id、roll_pointer</p><ul><li><p><strong>row_id</strong>：占 6 个字节， 如果我们建表的时候指定了主键或者唯一约束列，那么就没有 row_id 隐藏字段了。否则 InnoDB 就会为记录添加 row_id 隐藏字段。row_id 不是必需的。</p></li><li><p><strong>trx_id</strong>：占 6 个字节，事务 id，表示这个数据是由哪个事务生成的。 trx_id 是必需的。</p></li><li><p><strong>roll_pointer</strong>：占 7 个字节，这条记录上一个版本的指针。roll_pointer 是必需的。</p></li></ul><h3 id="行溢出"><a class="anchor" href="#行溢出">#</a> 行溢出</h3><p>默认的数据页大小是 16KB，一行的字节大小不能超过数据页的大小，当一行的字节大小超过数据页的大小时，这个行就无法存储在单个数据页中，这被称为行溢出（<strong>row overflow</strong>）。</p><p>为了处理行溢出的情况，MySQL 提供了一种机制，即将溢出的数据存储在额外的数据页中，并通过指针进行引用。但是，这种行溢出的处理会增加额外的存储和访问成本，并且可能影响查询性能。</p><p>为了避免行溢出的情况，MySQL 限制了一行的字节大小不能超过数据页的大小。对于 InnoDB 存储引擎，默认情况下，一行的字节大小不能超过 65535 个字节（64KB - 1）。</p><p>一些大对象如 TEXT、BLOB 可能存储更多的数据，这时一个页可能就存不了一条记录。这个时候就会<strong>发生行溢出，多的数据就会存到另外的「溢出页」中</strong>。</p><p>Compact 行格式发生行溢出时，在记录的真实数据处只会保存该列的一部分数据，而把剩余的数据放在「溢出页」中，然后真实数据处用 20 字节存储指向溢出页的地址，从而可以找到剩余数据所在的页。大致如下图所示。</p><p>Compressed 和 Dynamic 行格式发生行溢出时，只存储 20 个字节的指针来指向溢出页，而实际的数据都存储在溢出页中。</p><h1 id="索引"><a class="anchor" href="#索引">#</a> 索引</h1><p>索引的定义就是帮助存储引擎快速获取数据的一种数据结构，索引是数据的目录。</p><h2 id="索引的分类"><a class="anchor" href="#索引的分类">#</a> 索引的分类</h2><ul><li>按「数据结构」分类：<strong>B+tree 索引、Hash 索引、Full-text 索引</strong>。</li><li>按「物理存储」分类：<strong>聚簇索引（主键索引）、二级索引（辅助索引）</strong>。</li><li>按「字段特性」分类：<strong>主键索引、唯一索引、普通索引、前缀索引</strong>。</li><li>按「字段个数」分类：<strong>单列索引、联合索引</strong>。</li></ul><p><strong>1. 按数据结构分类</strong></p><p>从数据结构的角度来看，MySQL 常见索引有 B+Tree 索引、HASH 索引、Full-Text 索引。</p><table><thead><tr><th>索引类型</th><th>InnoDB</th><th>MyISAM</th><th>Memory</th></tr></thead><tbody><tr><td>B+Tree</td><td>yes</td><td>yes</td><td>yes</td></tr><tr><td>HASH</td><td>no (但是在内存结构中有一个自适应的 hash 索引)</td><td>no</td><td>yes</td></tr><tr><td>Full-Text</td><td>yes</td><td>yes</td><td>no</td></tr></tbody></table><p>InnoDB 是在 MySQL 5.5 之后成为默认的 MySQL 存储引擎，B+Tree 索引类型也是 MySQL 存储引擎采用最多的索引类型。</p><p>在创建表时，InnoDB 存储引擎会根据不同的场景选择不同的列作为索引：</p><ul><li>如果有主键，默认会使用主键作为聚簇索引的索引键（key）；</li><li>如果没有主键，就选择第一个不包含 NULL 值的唯一列作为聚簇索引的索引键（key）；</li><li>在上面两个都没有的情况下，InnoDB 将自动生成一个隐式自增 id 列作为聚簇索引的索引键（key）；</li></ul><p>除主键索引外，其它索引都属于辅助索引（Secondary Index），也被称为二级索引或非聚簇索引。<br><strong>创建的主键索引和二级索引默认使用的是 B+Tree 索引</strong>。</p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311072256460.png" alt="主键索引 B+Tree"></p><p><strong>2. 按物理存储分类</strong></p><p>从物理存储的角度来看，索引分为聚簇索引（主键索引）、二级索引（辅助索引）。</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>所以，在查询时使用了二级索引，如果查询的数据能在二级索引里查询的到，那么就不需要回表，这个过程就是<strong>覆盖索引</strong>。<br>如果查询的数据不在二级索引里，就会先检索二级索引，找到对应的叶子节点，获取到主键值后，然后再检索主键索引，就能查询到数据了，这个过程就是<strong>回表</strong>。</p><p><strong>3. 按照字段特性分类</strong></p><p>从字段特性的角度来看，索引分为主键索引、唯一索引、普通索引、前缀索引。</p><p><strong>主键索引</strong>就是建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><p><strong>唯一索引</strong>建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><p><strong>普通索引</strong>就是建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><p><strong>前缀索引</strong>是指对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><p><strong>4. 按字段个数分类</strong></p><p>从字段个数的角度来看，索引分为单列索引、联合索引（复合索引）。</p><p>通过将多个字段组合成一个索引，该索引就被称为<strong>联合索引</strong>。</p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311072256407.png" alt="联合索引"></p><h2 id="索引的查询过程"><a class="anchor" href="#索引的查询过程">#</a> 索引的查询过程</h2><p><strong>1. 通过主键查询</strong></p><p>B+Tree 会自顶向下逐层进行查找</p><p>数据库的索引和数据都是存储在硬盘的，我们可以把读取一个节点当作一次磁盘 I/O 操作。那么上面的整个查询过程一共经历了 3 个节点，也就是进行了 3 次 I/O 操作。</p><p>B+Tree 存储千万级的数据只需要 3-4 层高度就可以满足，这意味着从千万级的表查询目标数据最多需要 3-4 次磁盘 I/O，所以<strong> B+Tree 相比于 B 树和二叉树来说，最大的优势在于查询效率很高，因为即使在数据量很大的情况，查询一个数据的磁盘 I/O 依然维持在 3-4 次。</strong></p><p><strong>2. 通过二级索引查询</strong></p><p>主键索引的 B+Tree 和二级索引的 B+Tree 区别如下：</p><ul><li>主键索引的 B+Tree 的叶子节点存放的是实际数据，所有完整的用户记录都存放在主键索引的 B+Tree 的叶子节点里；</li><li>二级索引的 B+Tree 的叶子节点存放的是主键值，而不是实际数据。</li></ul><p>会先检二级索引中的 B+Tree 的索引值，找到对应的叶子节点，然后获取主键值，然后再通过主键索引中的 B+Tree 树查询到对应的叶子节点，然后获取整行数据。<strong>这个过程叫「回表」，也就是说要查两个 B+Tree 才能查到数据</strong>。</p><p>当查询的数据是能在二级索引的 B+Tree 的叶子节点里查询到，这时就不用再查主键索引查。<strong>这种在二级索引的 B+Tree 就能查询到结果的过程就叫作「覆盖索引」，也就是只需要查一个 B+Tree 就能找到数据</strong>。</p><p><strong>3. 联合索引查询</strong></p><p>联合索引的非叶子节点用两个字段的值作为 B+Tree 的 key 值。当在联合索引查询数据时，先按第一个字段比较，在第一个相同的情况下再按第二个字段比较。</p><p>使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。在使用联合索引进行查询的时候，如果不遵循「最左匹配原则」，联合索引会失效，这样就无法利用到索引快速查询的特性了。</p><p><strong>利用索引的前提是索引里的 key 是有序的</strong>。</p><p><strong>4. 联合索引范围查询</strong></p><p>可能存在部分字段用到联合索引的 B+Tree，部分字段没有用到联合索引的 B+Tree 的情况。</p><p>联合索引的最左匹配原则，在遇到范围查询的时候，就会停止匹配，也就是范围查询的字段可以用到联合索引，但是在范围查询字段的后面的字段无法用到联合索引。注意，对于 &gt;=、&lt;=、BETWEEN、like 前缀匹配的范围查询，并不会停止匹配.</p><p><strong>5. 联合索引排序</strong></p><p>使用了联合索引，进行排序可能会 filesort // TODO 整理过一个文档，改天找找</p><p>利用索引的有序性，筛选完了之后是排序好的，避免 filesort 提高效率</p><p><strong>6. 索引下推</strong></p><p>可以在联合索引遍历过程中，对联合索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p><p>当查询语句的执行计划里，出现了 Extra 为 <code>Using index condition</code> ，那么说明使用了索引下推的优化。</p><h2 id="查询explain"><a class="anchor" href="#查询explain">#</a> 查询 EXPLAIN</h2><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">EXPLAIN</span> <span class="token keyword">select</span> <span class="token operator">*</span> <span class="token keyword">from</span> t_user <span class="token keyword">where</span> id <span class="token operator">+</span><span class="token number">1</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311072256802.png" alt="img"></p><ul><li>possible_keys 字段表示可能用到的索引；</li><li>key 字段表示实际用的索引，如果这一项为 NULL，说明没有使用索引；</li><li>key_len 表示索引的长度；</li><li>rows 表示扫描的数据行数。</li><li>type 表示数据扫描类型。</li></ul><p>type 字段有，常见扫描类型的<strong>执行效率从低到高的顺序为</strong>：</p><ul><li>All（全表扫描）；</li><li>index（全索引扫描）；</li><li>range（索引范围扫描）只检索给定范围的行，属于范围查找。</li><li>ref（非唯一索引扫描）是使用了非唯一索引或者是唯一索引的非唯一性前缀，返回数据返回可能是多条。</li><li>eq_ref（唯一索引扫描）是使用主键或唯一索引时产生的访问方式。</li><li>const（结果只有一条的主键或唯一索引扫描）是使用了主键或者唯一索引与常量值进行比较。</li></ul><p>extra 字段，比较重要的有</p><ul><li>Using filesort ：当查询语句中包含 group by 操作，而且无法利用索引完成排序操作的时候， 这时不得不选择相应的排序算法进行，甚至可能会通过文件排序，效率是很低的，所以要避免这种问题的出现。</li><li>Using temporary：使了用临时表保存中间结果，MySQL 在对查询结果排序时使用临时表，常见于排序 order by 和分组查询 group by。效率低，要避免这种问题的出现。</li><li>Using index：所需数据只需在索引即可全部获得，不须要再到表中取数据，也就是使用了覆盖索引，避免了回表操作，效率不错。</li></ul><h2 id="索引失效"><a class="anchor" href="#索引失效">#</a> 索引失效</h2><p><strong>1. 索引区分度</strong></p><pre><code>区分度 = distinct(column) / count(*) 
</code></pre><p>查询优化器发现某个值出现在表的数据行中的百分比（惯用的百分比界线是 &quot;30%&quot;）很高的时候，它一般会忽略索引，进行全表扫描</p><p><strong>2. 索引被计算</strong><br>左或者左右模糊匹配<br>在查询条件中对索引列做了计算、函数、类型转换操作</p><p><strong>3. 没命中索引</strong><br>WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。</p><p>等等</p><h2 id="索引面试题"><a class="anchor" href="#索引面试题">#</a> 索引面试题</h2><p><strong>1. 为什么单表不要超过 2000w 行？</strong></p><p>非叶子节点内指向其他页的数量为 x，索引页数据大小约为 15k, 索引页一条数据大概为 12byte，x=15*1024/12≈1280 行<br>叶子节点内能容纳的数据行数为 y，叶子页数据大小约为 15k, 假设一行数据 1k, Y = 15*1024/1000 ≈15 行<br>B+ 数的层数为 z<br>Total =x^(z-1) *y</p><p>如果 z = 2，Total = （1280 ^1 ）*15 = 19200<br>如果 z = 3，Total = （1280 ^2） *15 = 24576000 （约 2.45kw）</p><p>如果叶子节点内一行数据 15k，则 Y = 1<br>如果 z = 2，Y = 1 ,Total = （1280 ^1 ）*1 = 1280<br>如果 z = 3，Y = 1, Total = （1280 ^2） *1 = 1638400 （约 1 百万）</p><p>所以，在保持相同的层级（相似查询性能）的情况下，在行数据大小不同的情况下，其实这个最大建议值也是不同的，而且影响查询性能的还有很多其他因素，比如，数据库版本，服务器配置，sql 的编写等等。</p><p>当单表数据库到达某个量级的上限时，导致内存无法存储其索引，使得之后的 SQL 查询会产生磁盘 IO，从而导致性能下降，所以增加硬件配置（比如把内存当磁盘使），可能会带来立竿见影的性能提升哈。</p><h1 id="事务"><a class="anchor" href="#事务">#</a> 事务</h1><ul><li><strong>原子性（Atomicity）</strong>：一个事务中的所有操作，要么全部完成，要么全部不完成。</li><li><strong>一致性（Consistency）</strong>：是指事务操作前和操作后，数据满足完整性约束。</li><li><strong>隔离性（Isolation）</strong>：多个并发事务相互操作是隔离的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>MyISAM 引擎不支持事务</p><p><strong>InnoDB 引擎通过以下技术来保证事务的这四个特性</strong></p><ul><li><strong>原子性</strong> (A) 是通过 undo log（回滚日志） 来保证的；一个事务中的所有操作，要么全部完成，要么全部不完成。</li><li><strong>一致性</strong> (C) 则是通过持久性 + 原子性 + 隔离性来保证；是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。</li><li><strong>隔离性</strong> (I) 是通过 MVCC（多版本并发控制） 或锁机制来保证的；允许多个并发事务同时对其数据进行读写和修改的能力。</li><li><strong>持久性</strong> (D) 是通过 redo log （重做日志）来保证的；事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p><strong>并行事务会引发的问题</strong></p><p><strong>脏读</strong>（dirty read）: 读到其他事务未提交的数据。</p><p><strong>不可重复读</strong>（non-repeatable read）：前后读取的数据不一致。</p><p><strong>幻读</strong>（phantom read）：前后读取的记录数量不一致。</p><h2 id="事务的隔离级别"><a class="anchor" href="#事务的隔离级别">#</a> <strong>事务的隔离级别</strong></h2><ul><li><p><strong>读未提交</strong>（Read Uncommitted）：最低级别的隔离级别，允许一个事务读取另一个事务尚未提交的数据。这种隔离级别可能导致脏读（Dirty Read），即读取到未提交的数据。</p></li><li><p><strong>读提交</strong>（Read Committed）：要求一个事务只能读取已经提交的数据。这种隔离级别可以避免脏读，但可能会导致不可重复读（Non-repeatable Read），即在同一个事务中，多次读取同一数据得到不同的结果。</p></li><li><p><strong>可重复读</strong>（Repeatable Read）：要求在一个事务中多次读取同一数据时，得到的结果保持一致。这种隔离级别可以避免脏读和不可重复读，但可能会导致幻读（Phantom Read），即在同一个事务中，多次查询得到不同的数据行数。<strong>MySQL InnoDB 引擎的默认隔离级别</strong></p></li><li><p><strong>串行化</strong>（Serializable）：最高级别的隔离级别，要求事务串行执行，完全隔离事务之间的影响。它可以避免脏读、不可重复读和幻读，但会牺牲并发性能。</p></li></ul><p><strong>事务隔离级别实现方式：</strong></p><p><strong>读未提交</strong>：直接读取最新的数据就好了</p><p><strong>读提交</strong>：每个语句执行前生成 Read View</p><p><strong>可重复读</strong>：启动事务时，生成 Read View，整个事务期间都用这个 Read View</p><p><strong>串行化</strong>：加读写锁的方式来避免并行访问</p><h2 id="mvcc"><a class="anchor" href="#mvcc">#</a> MVCC</h2><p>Multi-Version Concurrency Control 多版本并发控制</p><h3 id="实现原理"><a class="anchor" href="#实现原理">#</a> 实现原理</h3><h4 id="隐藏字段"><a class="anchor" href="#隐藏字段">#</a> <strong>隐藏字段</strong></h4><p>InnoDB 下的 Compact 行结构，有三个隐藏的列，如上文所述</p><ul><li><p><code>row_id</code> : 主键或者唯一约束列，占用 6 个字节。</p></li><li><p><code>trx_id</code> : 事务 id，表示这个数据是由哪个事务生成的。占用 6 个字节。</p></li><li><p><code>roll_pointer</code> : 回滚指针，指向这条记录的 undo log 信息。占用 7 个字节。</p></li></ul><h4 id="readview"><a class="anchor" href="#readview">#</a> <strong>ReadView</strong></h4><p>主要是用来做可见性判断，里面保存了 “当前对本事务不可见的其他活跃事务”</p><p>主要有以下字段：</p><ul><li><code>m_low_limit_id</code> ：目前出现过的最大的事务 ID+1，即下一个将被分配的事务 ID。大于等于这个 ID 的数据版本均不可见</li><li><code>m_up_limit_id</code> ：活跃事务列表 <code>m_ids</code> 中最小的事务 ID，如果 <code>m_ids</code> 为空，则 <code>m_up_limit_id</code> 为 <code>m_low_limit_id</code> 。小于这个 ID 的数据版本均可见</li><li><code>m_ids</code> ： <code>Read View</code> 创建时其他未提交的活跃事务 ID 列表。创建 <code>Read View</code> 时，将当前未提交事务 ID 记录下来，后续即使它们修改了记录行的值，对于当前事务也是不可见的。 <code>m_ids</code> 不包括当前事务自己和已提交的事务（正在内存中）</li><li><code>m_creator_trx_id</code> ：创建该 <code>Read View</code> 的事务 ID</li></ul><p><strong>事务可见性</strong></p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311071134111.png" alt="trans_visible"></p><h4 id="undo-log"><a class="anchor" href="#undo-log">#</a> <strong>undo log</strong></h4><p>主要作用</p><ul><li>当事务回滚时用于将数据恢复到修改前的样子</li><li><code>MVCC</code> ，当读取记录时，若该记录被其他事务占用或当前版本对该事务不可见，则可以通过 <code>undo log</code> 读取之前的版本数据，以此实现非锁定读</li></ul><p>不同事务或者相同事务的对同一记录行的修改，会使该记录行的 <code>undo log</code> 成为一条链表，链首就是最新的记录，链尾就是最早的旧记录。</p><h2 id="怎么避免幻读"><a class="anchor" href="#怎么避免幻读">#</a> 怎么避免幻读</h2><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了），解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select ... for update 等语句），是<strong>通过 next-key lock（记录锁 + 间隙锁）方式解决了幻读</strong>，因为当执行 select ... for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><p>两个发生幻读场景的例子</p><p>第一个例子：对于快照读， MVCC 并不能完全避免幻读现象。因为当事务 A 更新了一条事务 B 插入的记录，那么事务 A 前后两次查询的记录条目就不一样了，所以就发生幻读。</p><p>第二个例子：对于当前读，如果事务开启后，并没有执行当前读，而是先快照读，然后这期间如果其他事务插入了一条记录，那么事务后续使用当前读进行查询的时候，就会发现两次查询的记录条目就不一样了，所以就发生幻读。</p><h1 id="锁"><a class="anchor" href="#锁">#</a> 锁</h1><h2 id="分类"><a class="anchor" href="#分类">#</a> 分类</h2><h3 id="全局锁"><a class="anchor" href="#全局锁">#</a> 全局锁</h3><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 加全局锁</span></pre></td></tr><tr><td data-num="2"></td><td><pre>flush <span class="token keyword">tables</span> <span class="token keyword">with</span> <span class="token keyword">read</span> <span class="token keyword">lock</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 释放全局锁</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">unlock</span> <span class="token keyword">tables</span></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update 等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>当会话断开了，全局锁会被自动释放。</p><p>全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><blockquote><p>避免全局锁，去备份数据库的办法<br>数据库引擎支持可重复读的隔离级别，在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。</p></blockquote><h3 id="表级锁"><a class="anchor" href="#表级锁">#</a> 表级锁</h3><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h4 id="表锁"><a class="anchor" href="#表锁">#</a> 表锁</h4><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 表级别的共享锁，也就是读锁；</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">lock</span> <span class="token keyword">tables</span> t_student <span class="token keyword">read</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 表级别的独占锁，也就是写锁；</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">lock</span> <span class="token keyword">tables</span> t_stuent <span class="token keyword">write</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre></pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token comment">-- 释放表锁</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">unlock</span> <span class="token keyword">tables</span></pre></td></tr></table></figure><p>表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>当会话退出后，也会释放所有表锁。</p><h4 id="元数据锁"><a class="anchor" href="#元数据锁">#</a> 元数据锁</h4><p><strong>元数据锁</strong> metadata lock（MDL）</p><p>我们不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是为了保证当用户对表执行 CRUD 操作时，防止其他线程对这个表结构做了变更。</p><p>MDL 在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><h4 id="意向锁"><a class="anchor" href="#意向锁">#</a> 意向锁</h4><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p><p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 先在表上加上意向共享锁，然后对读取的记录加共享锁</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 先表上加上意向独占锁，然后对读取的记录加独占锁</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。</p><p>如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。</p><p>那么有了「意向锁」，由于在对记录加独占锁前，先会加上表级别的意向独占锁，那么在加「独占表锁」时，直接查该表是否有意向独占锁，如果有就意味着表里已经有记录被加了独占锁，这样就不用去遍历表里的记录。</p><p>所以，<strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h4 id="auto-inc-锁"><a class="anchor" href="#auto-inc-锁">#</a> AUTO-INC 锁</h4><p>自增主键 <code>AUTO_INCREMENT</code> ，在插入数据时，会锁住表级的 AUTO-INC 锁，保证自增主键的值是连续递增的。</p><p>但是， AUTO-INC 锁再对大量数据进行插入的时候，会影响插入性能，因为另一个事务中的插入会被阻塞。</p><p>因此， 在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为自增主键加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h3 id="行级锁"><a class="anchor" href="#行级锁">#</a> 行级锁</h3><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>前面也提到，普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p><figure class="highlight sql"><figcaption data-lang="SQL"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">-- 对读取的记录加共享锁</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">lock</span> <span class="token operator">in</span> <span class="token keyword">share</span> <span class="token keyword">mode</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token comment">-- 对读取的记录加独占锁</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token keyword">select</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">for</span> <span class="token keyword">update</span><span class="token punctuation">;</span></pre></td></tr></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>。</p><p>共享锁（S 锁）满足读读共享，读写互斥。独占锁（X 锁）满足写写互斥、读写互斥。</p><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h4 id="record-lock"><a class="anchor" href="#record-lock">#</a> Record Lock</h4><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311071622632.png" alt="img"></p><h4 id="gap-lock"><a class="anchor" href="#gap-lock">#</a> Gap Lock</h4><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><h4 id="next-key-lock"><a class="anchor" href="#next-key-lock">#</a> Next-Key Lock</h4><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。</p><p>next-key lock 是包含间隙锁 + 记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的。</p><h4 id="插入意向锁"><a class="anchor" href="#插入意向锁">#</a> 插入意向锁</h4><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有其他间隙锁的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><h3 id="怎么避免死锁"><a class="anchor" href="#怎么避免死锁">#</a> 怎么避免死锁</h3><p>死锁的四个必要条件：<strong>互斥、占有且等待、不可强占用、循环等待</strong>。只要系统发生死锁，这些条件必然成立，但是只要破坏任意一个条件就死锁就不会成立。</p><p>在数据库层面，有两种策略通过「打破循环等待条件」来解除死锁状态：</p><ul><li><strong>设置事务等待锁的超时时间</strong>。当一个事务的等待时间超过该值后，就对这个事务进行回滚，于是锁就释放了，另一个事务就可以继续执行了。在 InnoDB 中，参数 <code>innodb_lock_wait_timeout</code> 是用来设置超时时间的，默认值时 50 秒。</li><li><strong>开启主动死锁检测</strong>。主动死锁检测在发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 <code>innodb_deadlock_detect</code> 设置为 on，表示开启这个逻辑，默认就开启。</li></ul><h1 id="日志"><a class="anchor" href="#日志">#</a> 日志</h1><ul><li><strong>undo log（回滚日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>原子性</strong>，主要<strong>用于事务回滚和 MVCC</strong>。</li><li><strong>redo log（重做日志）</strong>：是 Innodb 存储引擎层生成的日志，实现了事务中的<strong>持久性</strong>，主要<strong>用于掉电等故障恢复</strong>；</li><li><strong>binlog （归档日志）</strong>：是 Server 层生成的日志，主要<strong>用于数据备份和主从复制</strong>；</li></ul><h2 id="undo-log-2"><a class="anchor" href="#undo-log-2">#</a> undo log</h2><p>undo log（回滚日志）</p><p><strong>undo log 的作用：</strong></p><ul><li><strong>实现事务回滚，保障事务的原子性</strong>。事务处理过程中，如果出现了错误或者用户执 行了 ROLLBACK 语句，MySQL 可以利用 undo log 中的历史数据将数据恢复到事务开始之前的状态。</li><li><strong>实现 MVCC（多版本并发控制）关键因素之一</strong>。MVCC 是通过 ReadView + undo log 实现的。undo log 为每条记录保存多份历史数据，MySQL 在执行快照读（普通 select 语句）的时候，会根据事务的 Read View 里的信息，顺着 undo log 的版本链找到满足其可见性的记录。</li></ul><p><strong>undo log 持久化的流程</strong>：<br>undo log 和数据页的刷盘策略是一样的，都需要通过 redo log 保证持久化。buffer pool 中有 undo 页，对 undo 页的修改也都会记录到 redo log。redo log 会每秒刷盘，提交事务时也会刷盘，数据页和 undo 页都是靠这个机制保证持久化的。</p><h2 id="redo-log"><a class="anchor" href="#redo-log">#</a> redo log</h2><p>redo log（重做日志）</p><p>redo log 是物理日志，记录了某个数据页做了什么修改，比如<strong>对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了 AAA 更新</strong>，每当执行一个事务就会产生这样的一条或者多条物理日志。</p><p><strong>redo log 的作用：</strong><br>为了防止断电导致数据丢失的问题，当有一条记录需要更新的时候，InnoDB 引擎就会先更新内存（同时标记为脏页），然后将本次对这个页的修改以 redo log 的形式记录下来，这个时候更新就算完成了。</p><p>redo log 和 undo log 的<strong>区别</strong>：<br>redo log 记录了此次事务「<strong>完成后</strong>」的数据状态，记录的是更新<strong>之后</strong>的值；<br>undo log 记录了此次事务「<strong>开始前</strong>」的数据状态，记录的是更新<strong>之前</strong>的值；</p><p><strong>redo log 的持久化流程</strong>：<br>在事务提交时，只要先将 redo log 持久化到磁盘即可，可以不需要等到将缓存在 Buffer Pool 里的脏页数据持久化到磁盘。<br>当系统崩溃时，虽然脏页数据没有持久化，但是 redo log 已经持久化，接着 MySQL 重启后，可以根据 redo log 的内容，将所有数据恢复到最新的状态。</p><p><strong>redo log 的持久化时机</strong>：</p><ul><li>MySQL 正常关闭时；</li><li>当 redo log buffer 中记录的写入量大于 redo log buffer 内存空间的一半时，会触发落盘；</li><li>InnoDB 的后台线程每隔 1 秒，将 redo log buffer 持久化到磁盘。</li><li>每次事务提交时都将缓存在 redo log buffer 里的 redo log 直接持久化到磁盘</li></ul><p>当 redo log 的文件写满了，他会从头开始覆盖重新写，相当于一个环形。</p><h2 id="bin-log"><a class="anchor" href="#bin-log">#</a> bin log</h2><p>MySQL 在完成一条更新操作后，Server 层还会生成一条 binlog，等之后事务提交的时候，会将该事务执行过程中产生的所有 binlog 统一写 入 binlog 文件。</p><p><strong>binlog 和 redo log 的区别</strong>：</p><p>1、适用对象不同：</p><ul><li>binlog 是 MySQL 的 Server 层实现的日志，所有存储引擎都可以使用；</li><li>redo log 是 Innodb 存储引擎实现的日志；</li></ul><p>2、文件格式不同：</p><ul><li>binlog 有 3 种格式类型，分别是 STATEMENT（默认格式）、ROW、 MIXED，区别如下：<ul><li>STATEMENT：每一条修改数据的 SQL 都会被记录到 binlog 中（相当于记录了逻辑操作，所以针对这种格式， binlog 可以称为逻辑日志），主从复制中 slave 端再根据 SQL 语句重现。但 STATEMENT 有动态函数的问题，比如你用了 uuid 或者 now 这些函数，你在主库上执行的结果并不是你在从库执行的结果，这种随时在变的函数会导致复制的数据不一致；</li><li>ROW：记录行数据最终被修改成什么样了（这种格式的日志，就不能称为逻辑日志了），不会出现 STATEMENT 下动态函数的问题。但 ROW 的缺点是每行数据的变化结果都会被记录，比如执行批量 update 语句，更新多少行数据就会产生多少条记录，使 binlog 文件过大，而在 STATEMENT 格式下只会记录一个 update 语句而已；</li><li>MIXED：包含了 STATEMENT 和 ROW 模式，它会根据不同的情况自动使用 ROW 模式和 STATEMENT 模式；</li></ul></li><li>redo log 是物理日志，记录的是在某个数据页做了什么修改，比如对 XXX 表空间中的 YYY 数据页 ZZZ 偏移量的地方做了 AAA 更新；</li></ul><p>3、写入方式不同：</p><ul><li>binlog 是追加写，写满一个文件，就创建一个新的文件继续写，不会覆盖以前的日志，保存的是全量的日志。</li><li>redo log 是循环写，日志空间大小是固定，全部写满就从头开始，保存未被刷入磁盘的脏页日志。</li></ul><p>4、用途不同：</p><ul><li>binlog 用于备份恢复、主从复制；</li><li>redo log 用于掉电等故障恢复。</li></ul><p><strong>binlog 持久化</strong><br>事务执行过程中，先把日志写到 binlog cache（Server 层的 cache），事务提交的时候，再把 binlog cache 写到 binlog 文件中，并且清空 binlog cache<br>一个事务的 binlog 是不能被拆开的，因此无论这个事务有多大（比如有很多条语句），也要保证一次性写入。<br>每个线程都有自己的 binlog cache，但是最终都写到同一个 binlog 文件</p><h3 id="主从复制"><a class="anchor" href="#主从复制">#</a> 主从复制</h3><p>MySQL 的主从复制依赖于 binlog ，也就是记录 MySQL 上的所有变化并以二进制形式保存在磁盘上。复制的过程就是将 binlog 中的数据从主库传输到从库上。<br>这个过程一般是<strong>异步</strong>的，也就是主库上执行事务操作的线程不会等待复制 binlog 的线程同步完成。</p><p>MySQL 集群的主从复制过程梳理成 3 个阶段：</p><ul><li><strong>写入 Binlog</strong>：主库写 binlog 日志，提交事务，并更新本地存储数据。</li><li><strong>同步 Binlog</strong>：把 binlog 复制到所有从库上，每个从库把 binlog 写到暂存日志中。</li><li><strong>回放 Binlog</strong>：回放 binlog，并更新存储引擎中的数据。</li></ul><p>主从复制模型</p><ul><li><strong>同步复制</strong>：MySQL 主库提交事务的线程要等待所有从库的复制成功响应，才返回客户端结果。这种方式在实际项目中，基本上没法用，原因有两个：一是性能很差，因为要复制到所有节点才返回响应；二是可用性也很差，主库和所有从库任何一个数据库出问题，都会影响业务。</li><li><strong>异步复制</strong>（默认模型）：MySQL 主库提交事务的线程并不会等待 binlog 同步到各从库，就返回客户端结果。这种模式一旦主库宕机，数据就会发生丢失。</li><li><strong>半同步复制</strong>：MySQL 5.7 版本之后增加的一种复制方式，介于两者之间，事务线程不用等待所有的从库复制成功响应，只要一部分复制成功响应回来就行，比如一主二从的集群，只要数据成功复制到任意一个从库上，主库的事务线程就可以返回给客户端。这种<strong>半同步复制的方式，兼顾了异步复制和同步复制的优点，即使出现主库宕机，至少还有一个从库有最新的数据，不存在数据丢失的风险</strong>。</li></ul><h2 id="buffer-pool"><a class="anchor" href="#buffer-pool">#</a> Buffer Pool</h2><p>缓冲池（Buffer Pool）</p><p>Buffer Pool 的目的：提高数据库的读写性能</p><p>Buffer Pool 的作用：</p><ul><li>当读取数据时，如果数据存在于 Buffer Pool 中，客户端就会直接读取 Buffer Pool 中的数据，否则再去磁盘中读取。</li><li>当修改数据时，如果数据存在于 Buffer Pool 中，那直接修改 Buffer Pool 中数据所在的页，然后将其页设置为脏页（该页的内存数据和磁盘上的数据已经不一致），为了减少磁盘 I/O，不会立即将脏页写入磁盘，后续由后台线程选择一个合适的时机将脏页写入到磁盘。</li></ul><p>Buffer Pool 缓存了索引页，数据页，Undo 页，插入缓存、自适应哈希索引、锁信息等等。</p><p>当我们查询一条记录时，InnoDB 是会把整个页的数据加载到 Buffer Pool 中，将页加载到 Buffer Pool 后，再通过页里的「页目录」去定位到某条具体的记录。</p><p>Buffer Pool 的持久化流程：<br>InnoDB 引擎会在适当的时候，由后台线程将缓存在 Buffer Pool 的脏页刷新到磁盘里，这就是 <strong>WAL （Write-Ahead Logging）技术</strong>。<br><strong>WAL 技术指的是， MySQL 的写操作并不是立刻写到磁盘上，而是先写日志，然后在合适的时间再写到磁盘上</strong>。</p><h2 id="两阶段提交"><a class="anchor" href="#两阶段提交">#</a> 两阶段提交</h2><p>事务提交后，redo log 和 binlog 都要持久化到磁盘，但是这两个是独立的逻辑，可能出现半成功的状态，这样就造成两份日志之间的逻辑不一致。</p><p>如果有 redo log 没有 binlog，mysql 宕机重启后，主库值为正常值，从库值为旧值，数据不一致。<br>如果有 binlog 没有 redo log，mysql 宕机重启后，事务无效，从库同步到的为新值，数据不一致。</p><p>两阶段提交就是为了解决 MySQL 的两份日志之间的逻辑不一致的问题</p><p><strong>两阶段提交把单个事务的提交拆分成了 2 个阶段，分别是「准备（Prepare）阶段」和「提交（Commit）阶段」</strong>，每个阶段都由协调者（Coordinator）和参与者（Participant）共同完成。</p><p><strong>两阶段提交的过程：</strong></p><p>当客户端执行 commit 语句或者在自动提交的情况下，MySQL 内部开启一个 XA 事务，<strong>分两阶段来完成 XA 事务的提交</strong></p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311071755804.png" alt="两阶段提交"></p><p>事务的提交过程有两个阶段，就是<strong>将 redo log 的写入拆成了两个步骤：prepare 和 commit，中间再穿插写入 binlog</strong>，具体如下：</p><ul><li><strong>prepare 阶段</strong>：将 XID（内部 XA 事务的 ID） 写入到 redo log，同时将 redo log 对应的事务状态设置为 prepare，然后将 redo log 持久化到磁盘（innodb_flush_log_at_trx_commit = 1 的作用）；</li><li><strong>commit 阶段</strong>：把 XID 写入到 binlog ，然后将 binlog 持久化到磁盘（sync_binlog = 1 的作用），接着调用引擎的提交事务接口，将 redo log 状态设置为 commit，此时该状态并不需要持久化到磁盘，只需要 write 到文件系统的 page cache 中就够了，因为只要 binlog 写磁盘成功，就算 redo log 的状态还是 prepare 也没有关系，一样会被认为事务已经执行成功；</li></ul><p><strong>两阶段提交的问题：</strong></p><p>两阶段提交虽然保证了两个日志文件的数据一致性，但是性能很差，主要有两个方面的影响：</p><ul><li><strong>磁盘 I/O 次数高</strong>：对于 “双 1” 配置，每个事务提交都会进行两次 fsync（刷盘），一次是 redo log 刷盘，另一次是 binlog 刷盘。</li><li><strong>锁竞争激烈</strong>：两阶段提交虽然能够保证「单事务」两个日志的内容一致，但在「多事务」的情况下，却不能保证两者的提交顺序一致，因此，在两阶段提交的流程基础上，还需要加一个锁来保证提交的原子性，从而保证多事务的情况下，两个日志的提交顺序一致。</li></ul><p><strong>组提交：</strong></p><p>MySQL 引入了 binlog 组提交（group commit）机制，当有多个事务提交的时候，会将多个 binlog 刷盘操作合并成一个，从而减少磁盘 I/O 的次数。</p><p>引入了组提交机制后，prepare 阶段不变，只针对 commit 阶段，将 commit 阶段拆分为三个过程：</p><ul><li><strong>flush 阶段</strong>：多个事务按进入的顺序将 binlog 从 cache 写入文件（不刷盘）；</li><li><strong>sync 阶段</strong>：对 binlog 文件做 fsync 操作（多个事务的 binlog 合并一次刷盘）；</li><li><strong>commit 阶段</strong>：各个事务按顺序做 InnoDB commit 操作；</li></ul><p>上面的<strong>每个阶段都有一个队列</strong>，每个阶段有锁进行保护，因此保证了事务写入的顺序，第一个进入队列的事务会成为 leader，leader 领导所在队列的所有事务，全权负责整队的操作，完成后通知队内其他事务操作结束。</p><p>对每个阶段引入了队列后，锁就只针对每个队列进行保护，不再锁住提交事务的整个过程，可以看的出来，<strong>锁粒度减小了，这样就使得多个阶段可以并发执行，从而提升效率</strong>。</p><p><img data-src="https://twelveeee-note.oss-cn-beijing.aliyuncs.com/Image/202311071802522.png" alt="每个阶段都有一个队列"></p><div class="tags"><a href="/tags/MySQL/" rel="tag"><i class="ic i-tag"></i> MySQL</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2026-01-27 01:48:59" itemprop="dateModified" datetime="2026-01-27T01:48:59+08:00">2026-01-27</time></span></div><div id="copyright"><ul><li class="author"><strong>本文作者： </strong>Twelveeee <i class="ic i-at"><em>@</em></i>十二的编程笔记</li><li class="link"><strong>本文链接：</strong> <a href="https://blog.twelveeee.top/2023/Database/mysql_detail/" title="MySQL 详解">https://blog.twelveeee.top/2023/Database/mysql_detail/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/2023/AlgorithmCamp2023/06_binaryTree/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;twelveeee-note.oss-cn-beijing.aliyuncs.com&#x2F;Image&#x2F;img&#x2F;bgimg_54.webp" title="06&amp;07-二叉树遍历"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> 算法训练 2023</span><h3>06&07-二叉树遍历</h3></a></div><div class="item right"><a href="/2023/Go/Lib/urfave_cli/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;twelveeee-note.oss-cn-beijing.aliyuncs.com&#x2F;Image&#x2F;img&#x2F;bgimg_14.webp" title="Go urfave cli 使用"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Lib</span><h3>Go urfave cli 使用</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#mysql"><span class="toc-number">1.</span> <span class="toc-text">MySQL</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">2.</span> <span class="toc-text">数据查询过程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5"><span class="toc-number">2.1.</span> <span class="toc-text">连接</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E7%BC%93%E5%AD%98"><span class="toc-number">2.2.</span> <span class="toc-text">查询缓存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A7%A3%E6%9E%90"><span class="toc-number">2.3.</span> <span class="toc-text">解析</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C"><span class="toc-number">2.4.</span> <span class="toc-text">执行</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8"><span class="toc-number">2.4.1.</span> <span class="toc-text">预处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%99%A8"><span class="toc-number">2.4.2.</span> <span class="toc-text">优化器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E5%99%A8"><span class="toc-number">2.4.3.</span> <span class="toc-text">执行器</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.</span> <span class="toc-text">数据存储格式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A8%E7%A9%BA%E9%97%B4%E6%96%87%E4%BB%B6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.</span> <span class="toc-text">表空间文件的结构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%8C%E6%A0%BC%E5%BC%8F"><span class="toc-number">3.2.</span> <span class="toc-text">行格式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E9%A2%9D%E5%A4%96%E4%BF%A1%E6%81%AF"><span class="toc-number">3.2.1.</span> <span class="toc-text">记录的额外信息</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B0%E5%BD%95%E7%9A%84%E7%9C%9F%E5%AE%9E%E6%95%B0%E6%8D%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">记录的真实数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E6%BA%A2%E5%87%BA"><span class="toc-number">3.2.3.</span> <span class="toc-text">行溢出</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95"><span class="toc-number">4.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">4.1.</span> <span class="toc-text">索引的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E7%9A%84%E6%9F%A5%E8%AF%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">4.2.</span> <span class="toc-text">索引的查询过程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2explain"><span class="toc-number">4.3.</span> <span class="toc-text">查询 EXPLAIN</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"><span class="toc-number">4.4.</span> <span class="toc-text">索引失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">4.5.</span> <span class="toc-text">索引面试题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1"><span class="toc-number">5.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">事务的隔离级别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mvcc"><span class="toc-number">5.2.</span> <span class="toc-text">MVCC</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">5.2.1.</span> <span class="toc-text">实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9A%90%E8%97%8F%E5%AD%97%E6%AE%B5"><span class="toc-number">5.2.1.1.</span> <span class="toc-text">隐藏字段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#readview"><span class="toc-number">5.2.1.2.</span> <span class="toc-text">ReadView</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#undo-log"><span class="toc-number">5.2.1.3.</span> <span class="toc-text">undo log</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E5%B9%BB%E8%AF%BB"><span class="toc-number">5.3.</span> <span class="toc-text">怎么避免幻读</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%94%81"><span class="toc-number">6.</span> <span class="toc-text">锁</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.</span> <span class="toc-text">分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E9%94%81"><span class="toc-number">6.1.1.</span> <span class="toc-text">全局锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E7%BA%A7%E9%94%81"><span class="toc-number">6.1.2.</span> <span class="toc-text">表级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A1%A8%E9%94%81"><span class="toc-number">6.1.2.1.</span> <span class="toc-text">表锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%83%E6%95%B0%E6%8D%AE%E9%94%81"><span class="toc-number">6.1.2.2.</span> <span class="toc-text">元数据锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">6.1.2.3.</span> <span class="toc-text">意向锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#auto-inc-%E9%94%81"><span class="toc-number">6.1.2.4.</span> <span class="toc-text">AUTO-INC 锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E7%BA%A7%E9%94%81"><span class="toc-number">6.1.3.</span> <span class="toc-text">行级锁</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#record-lock"><span class="toc-number">6.1.3.1.</span> <span class="toc-text">Record Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#gap-lock"><span class="toc-number">6.1.3.2.</span> <span class="toc-text">Gap Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#next-key-lock"><span class="toc-number">6.1.3.3.</span> <span class="toc-text">Next-Key Lock</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%84%8F%E5%90%91%E9%94%81"><span class="toc-number">6.1.3.4.</span> <span class="toc-text">插入意向锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%80%8E%E4%B9%88%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81"><span class="toc-number">6.1.4.</span> <span class="toc-text">怎么避免死锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%97%A5%E5%BF%97"><span class="toc-number">7.</span> <span class="toc-text">日志</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#undo-log-2"><span class="toc-number">7.1.</span> <span class="toc-text">undo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redo-log"><span class="toc-number">7.2.</span> <span class="toc-text">redo log</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bin-log"><span class="toc-number">7.3.</span> <span class="toc-text">bin log</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6"><span class="toc-number">7.3.1.</span> <span class="toc-text">主从复制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#buffer-pool"><span class="toc-number">7.4.</span> <span class="toc-text">Buffer Pool</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E9%98%B6%E6%AE%B5%E6%8F%90%E4%BA%A4"><span class="toc-number">7.5.</span> <span class="toc-text">两阶段提交</span></a></li></ol></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li class="active"><a href="/2023/Database/mysql_detail/" rel="bookmark" title="MySQL 详解">MySQL 详解</a></li><li><a href="/2024/Database/innodb_update_all_table/" rel="bookmark" title="记录一次innodb 全表update">记录一次innodb 全表update</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="Twelveeee" data-src="/images/avatar.jpg"><p class="name" itemprop="name">Twelveeee</p><div class="description" itemprop="description">十二的编程笔记</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">123</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">31</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">26</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL3R3ZWx2ZWVlZQ==" title="https:&#x2F;&#x2F;github.com&#x2F;twelveeee"><i class="ic i-github"></i></span> <span class="exturl item email" data-url="bWFpbHRvOnR3ZWx2ZWVlZTEyQGdtYWlsLmNvbQ==" title="mailto:twelveeee12@gmail.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li><li class="item"><span class="exturl" data-url="aHR0cHM6Ly93d3cudHJhdmVsbGluZ3MuY24vZ28uaHRtbA=="><i class="ic i-paper-plane"></i>开往</span></li><li class="item"><a href="/friends/" rel="section"><i class="ic i-heart"></i>友链</a></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/2023/AlgorithmCamp2023/06_binaryTree/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/2023/Go/Lib/urfave_cli/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/algorithm2023/" title="分类于 算法训练 2023">算法训练 2023</a></div><span><a href="/2023/AlgorithmCamp2023/09_binarySearch/" title="09-二分查找">09-二分查找</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Java/" title="分类于 Java">Java</a></div><span><a href="/2021/JavaConcurrency/synchronized/" title="synchronized">synchronized</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Search/" title="分类于 Search">Search</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Search/Elasticsearch/" title="分类于 Elasticsearch">Elasticsearch</a></div><span><a href="/2021/Search/ElasticSearch/intro/" title="Elasticsearch 简介">Elasticsearch 简介</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Linux%E5%9F%BA%E7%A1%80/" title="分类于 Linux 基础">Linux 基础</a></div><span><a href="/2020/Linux/intro%20copy/" title="什么是操作系统">什么是操作系统</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/%E6%A0%88/" title="分类于 栈">栈</a></div><span><a href="/2020/DataStructure/Stack/stack%20application/" title="栈的应用">栈的应用</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/Project/" title="分类于 Project">Project</a></div><span><a href="/2024/Project/copilot-gpt4-service-ban/" title="GitHub Copilot封号及退款过程">GitHub Copilot封号及退款过程</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/GO/" title="分类于 GO">GO</a></div><span><a href="/2023/Go/go%20GC%20v1/" title="Go 三色标记GC详解">Go 三色标记GC详解</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/%E7%9F%A9%E9%98%B5/" title="分类于 矩阵">矩阵</a></div><span><a href="/2020/DataStructure/Matrix/symmetric%20matrix/" title="对称矩阵">对称矩阵</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/CTF/" title="分类于 CTF">CTF</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/CTF/BCTF2025/" title="分类于 BCTF2025">BCTF2025</a></div><span><a href="/2025/CTF/BCTF2025/ai/" title="BCTF2025-AI">BCTF2025-AI</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computerScience/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/" title="分类于 数据结构">数据结构</a> <i class="ic i-angle-right"></i> <a href="/categories/computerScience/dataStructure/%E6%8E%92%E5%BA%8F/" title="分类于 排序">排序</a></div><span><a href="/2020/DataStructure/Sort/merge%20sort/" title="归并排序">归并排序</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2020 – <span itemprop="copyrightYear">2026</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">Twelveeee @ Twelveeee</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">644k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:45</span></div><div class="beian-by"><a href="https://beian.miit.gov.cn/" target="_blank" rel="noopener noreferrer">闽ICP备20004781号</a></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"2023/Database/mysql_detail/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:!0,fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=default,fetch"></script><script src="//fastly.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script><script data-pjax>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?30195a9a0f4d22cd45e9d770a10c683f";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=G-F27X623LWT"></script><script data-pjax>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-F27X623LWT")</script>--></body></html>